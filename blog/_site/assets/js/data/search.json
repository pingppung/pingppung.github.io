[
  
  {
    "title": "ORM 엔티티 설계: Single Table, Table Per Class, Joined Table",
    "url": "/posts/orm-entity-design/",
    "categories": "Backend, ORM",
    "tags": "orm, entity design, database, spring boot, mysql",
    "date": "2024-11-24 12:33:00 +0900",
    





    
    "snippet": "처음에는 소설, 웹툰, 드라마, 영화와 같은 각각의 콘텐츠 유형에 대해 독립적인 엔티티를 만들어 관리하려고 했습니다. 하지만 콘텐츠 유형이 다양해질수록 공통된 속성을 공유하는 상위 클래스 Content를 만들어 상속 구조를 설계하는 것이 더 효율적이라고 판단했습니다.왜 상속 구조가 유용할까?      공통된 속성 관리모든 콘텐츠가 공통적으로 가지는 속...",
    "content": "처음에는 소설, 웹툰, 드라마, 영화와 같은 각각의 콘텐츠 유형에 대해 독립적인 엔티티를 만들어 관리하려고 했습니다. 하지만 콘텐츠 유형이 다양해질수록 공통된 속성을 공유하는 상위 클래스 Content를 만들어 상속 구조를 설계하는 것이 더 효율적이라고 판단했습니다.왜 상속 구조가 유용할까?      공통된 속성 관리모든 콘텐츠가 공통적으로 가지는 속성(예: 제목, 설명, 카데고리 등)을 상위 클래스에 정의하면 코드 중복을 줄이고, 확장성을 높일 수 있습니다.        유형별 속성 추가 가능각 콘텐츠에 특화된 속성은 하위 클래스에서 별도로 정의할 수 있습니다.        유지보수와 확장성 향상새로운 콘텐츠 유형(예: 음악, 게임)을 추가할 때도 기존 구조를 유지하면서 간단히 확장할 수 있습니다.  설계상위 클래스: Content공통 속성 정의@Entitypublic class Content {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String title;    private String description;    private String category;}하위 클래스: 소설, 웹툰, 드라마, 영화각각의 고유한 속성 정의@Entitypublic class Novel extends Content {    private String author;    private int pageCount;}@Entitypublic class Webtoon extends Content {    private String artist;    private int episodeCount;}@Entitypublic class Drama extends Content {    private int seasonCount;    private String broadcaster;}@Entitypublic class Movie extends Content {    private int duration;    private String director;}상속 구조의 장점      코드 재사용성공통된 필드와 메서드를 상위 클래스에서 정의하여 중복 코드 제거할 수 있습니다.        확장성새로운 콘텐츠 유형을 추가하려면 단순히 Content를 상속하는 클래스만 만들면 됩니다.        ORM 전략의 유연성@Inheritance 어노테이션을 사용하여 Single Table, Table Per Class, Joined Table 등 다양한 테이블 설계 전략을 유연하게 선택할 수 있습니다.  테이블 설계 방식Single Table (단일 테이블)모든 데이터를 하나의 테이블에 저장하며, 쿼리는 빠르지만 필드가 많아지고 Null 값이 발생할 수 있습니다. 데이터가 많아지면 관리와 성능에 문제가 생길 수 있습니다.  Content Table            id      title      description      releaseDate      type      author      pageCount      artist      episodeCount      seasonCount      broadcaster      duration      director                  1      Novel A      Description      2024-01-01      Novel      Author A      300                                                        2      Webtoon B      Description      2024-02-01      Webtoon                    Artist B      50                                          3      Movie C      Description      2024-03-01      Movie                                                120      Director      모든 데이터를 하나의 테이블에 저장하여 조회 시 JOIN이 필요 없지만, 테이블이 커질수록 관리가 어려워지고, 필드가 많아져 불필요한 Null 값이 발생할 수 있습니다.Table Per Class (클래스별 테이블)각 하위 클래스가 고유 속성뿐만 아니라 공통 속성도 포함하는 테이블을 생성합니다. Content 테이블 없이 각 하위 클래스 테이블에 모든 데이터를 저장합니다.  Novel Table            id      title      description      releaseDate      author      pageCount                  1      Novel A      Description      2024-01-01      Author A      300        Webtoon Table            id      title      description      releaseDate      artist      episodeCount                  2      Webtoon B      Description      2024-02-01      Artist B      50      별도의 JOIN이 필요하지 않지만, 데이터 중복이 발생할 수 있고, 데이터 관리가 비효율적일 수 있습니다.Joined Table (조인 방식)공통 속성은 상위 테이블에 저장하고, 하위 클래스의 고유 속성은 별도의 테이블에 나눠 저장하는 방식입니다. 여러 테이블을 JOIN하여 데이터를 조회할 수 있지만, 쿼리가 복잡해지고 성능에 영향을 줄 수 있습니다.  Content Table            id      title      description      releaseDate                  1      Novel A      Description      2024-01-01              2      Webtoon B      Description      2024-02-01              3      Movie C      Description      2024-03-01        Novel Table            id      author      pageCount                  1      Author A      300        Webtoon Table            id      artist      episodeCount                  2      Artist B      50      데이터를 중복 없이 저장할 수 있지만, 조회 시 JOIN 연산이 많아져 성능에 영향을 미칠 수 있습니다.결론처음에는 공통된 속성을 Content 테이블에 저장하는 대신 각 콘텐츠 유형별로 별도의 테이블에 저장하는 방식인 Table Per Class 방식을 사용할 생각이었습니다. 하지만 이 방식을 사용하다 보니 데이터 중복이 발생하고, 관리가 복잡해지는 문제를 겪게 되었습니다. 또한, 여러 사이트에서 연재 중인 콘텐츠의 정보를 처리하는 과정에서 중복 데이터나 관계 설정의 어려움이 있었고, 이를 해결하는 데 어려움을 겪었습니다.결국, 더 효율적인 설계를 위해 다른 방식들을 고려하게 되었고, 그 경험과 해결 방법에 대해서는 다음 글에서 이어서 다루려고 합니다."
  },
  
  {
    "title": "MySQL 데이터 백업 및 복원",
    "url": "/posts/mysql-data/",
    "categories": "DevOps, Docker",
    "tags": "docker, spring boot, react, mysql, deployment",
    "date": "2024-10-11 12:33:00 +0900",
    





    
    "snippet": "로컬 환경에서 MySQL을 사용하다가 프로젝트가 진행되면서 Docker로 환경을 옮기게 됐다. Docker 환경으로 전환하면서, 로컬에서 작업했던 데이터가 Docker에서도 있을 거라 생각했다. 하지만 Docker 컨테이너에는 아무 데이터도 없었다. 로컬과 Docker는 완전히 별개 환경이기 때문에 데이터가 자동으로 전환되지 않는다는 점을 깨달았다.로...",
    "content": "로컬 환경에서 MySQL을 사용하다가 프로젝트가 진행되면서 Docker로 환경을 옮기게 됐다. Docker 환경으로 전환하면서, 로컬에서 작업했던 데이터가 Docker에서도 있을 거라 생각했다. 하지만 Docker 컨테이너에는 아무 데이터도 없었다. 로컬과 Docker는 완전히 별개 환경이기 때문에 데이터가 자동으로 전환되지 않는다는 점을 깨달았다.로컬 MySQL 데이터 백업로컬에서 MySQL 데이터를 백업하려면 mysqldump 명령어를 사용한다. 이 명령어는 데이터베이스의 테이블, 데이터, 인덱스 등을 SQL 파일로 추출해 저장한다. 아래와 같이 명령어를 실행하여 데이터를 백업할 수 있다.mysqldump -u root -p &lt;백업할 데이터베이스 이름&gt; &gt; &lt;데이터를 저장할 경로와 파일 이름&gt;mysqldump -u root -p contenthub &gt; C:\\Users\\pingppung\\Documents\\contenthub_dump.sql이 명령어로 로컬 데이터를 덤프 파일로 저장했다. 백업 경로를 정확하게 지정하지 않으면 파일이 저장되지 않는 문제가 생길 수 있으니 주의가 필요하다.덤프 파일이란?덤프 파일은 데이터베이스의 데이터를 파일로 추출한 것으로, 주로 백업이나 복원을 위해 사용된다. 이 파일에는 데이터베이스의 구조와 데이터가 SQL 쿼리문 형태로 저장된다. 예를 들어, 테이블을 생성하는 CREATE TABLE 문이나 데이터를 삽입하는 INSERT INTO 문이 포함되며, 이 파일을 이용해 데이터베이스를 복구할 수 있다.Docker 컨테이너로 데이터 복사로컬에서 백업한 contenthub_dump.sql 파일을 Docker 컨테이너로 복사해야 한다. docker cp 명령어를 사용하여 파일을 컨테이너로 전송할 수 있다.docker cp &lt;저장했던 파일 위치&gt; &lt;MySQL이 실행 중인 Docker 컨테이너 이름&gt;:&lt;컨테이너 내 파일을 저장할 경로&gt;docker cp C:\\Users\\pingppung\\Documents\\contenthub_dump.sql contenthub-db-1:/tmp/이 명령어로 contenthub_dump.sql 파일을 MySQL이 실행 중인 Docker 컨테이너의 /tmp/ 디렉토리로 복사했다.Docker에서 데이터 복원복사한 파일을 Docker 컨테이너 내에서 MySQL을 통해 복원할 수 있다. 컨테이너에 접속하여 MySQL에 로그인하고, 덤프 파일을 사용해 데이터를 복원한다.docker exec -it contenthub-db-1 mysql -u root -pUSE contenthub;SOURCE /tmp/contenthub_dump.sql;  docker exec -it contenthub-db-1 mysql -u root -p : MySQL이 실행 중인 Docker 컨테이너에 접속하고 MySQL에 로그인한다.  USE contenthub; : 복원할 데이터베이스를 선택한다.  SOURCE /tmp/contenthub_dump.sql; : 덤프 파일을 실행하여 데이터를 복원한다.위 이미지는 덤프 파일을 통해 데이터베이스를 복원하는 과정을 보여준다.  저는 이미 복원하려는 테이블이 데이터베이스에 존재하기 때문에 Query OK, 0 rows affected 메시지가 나오고 있습니다.복원이 완료된 후, 직접 데이터베이스에 접근해 제대로 데이터가 들어갔는지 확인했다. SELECT 쿼리를 사용해 데이터를 조회해 본 결과, 로컬에서 사용했던 데이터들이 모두 정상적으로 복원되어 있었다. 로컬에서 Docker로 환경을 옮기면서 발생했던 데이터 손실 문제를 이렇게 해결할 수 있었다.복원이 완료되어 회원가입했던 유저들의 정보들이 잘 넘어간 것을 볼 수 있다.마무리이처럼 로컬 환경에서 Docker 환경으로 전환하면서 데이터도 함께 옮기는 과정이 필요했다. 앞으로는 데이터의 안전성을 위해 항상 백업을 고려하는 것이 좋을 것 같다. 데이터 손실, 하드웨어 고장 또는 기타 문제를 방지하기 위해 정기적인 백업을 실시하고, 실제 운영 환경에서는 데이터가 매우 중요하므로 언제든지 복구할 수 있는 방법을 마련해 두는 것이 좋을 것 같다."
  },
  
  {
    "title": "Docker로 배포 자동화하기",
    "url": "/posts/docker/",
    "categories": "DevOps, Docker",
    "tags": "docker, spring boot, react, mysql, deployment",
    "date": "2024-09-27 12:33:00 +0900",
    





    
    "snippet": "개발 환경  spring boot 3.2.2  react 18.2.0  Node.js 18.x  docker 27.1.1  mysql 8.0.36  Gradle프로젝트 구조 및 환경이전에는 Spring Boot와 React를 통합 환경에서 작업했습니다. 즉, 백엔드 프로젝트 내에 프론트엔드를 포함한 형태였고, 배포할 때도 하나의 jar 파일을 만들어서...",
    "content": "개발 환경  spring boot 3.2.2  react 18.2.0  Node.js 18.x  docker 27.1.1  mysql 8.0.36  Gradle프로젝트 구조 및 환경이전에는 Spring Boot와 React를 통합 환경에서 작업했습니다. 즉, 백엔드 프로젝트 내에 프론트엔드를 포함한 형태였고, 배포할 때도 하나의 jar 파일을 만들어서 EC2에 올려서 실행했습니다. 이 방식은 초기에는 간편했지만, 프로젝트가 커지고 수정할 때마다 jar 파일을 생성해야 하는 번거로움이 있었습니다. 또 빌드 시간이 길어지는 문제도 발생했습니다.왜 프론트와 백엔드를 나누게 됐을까?프로젝트를 하면서 프론트엔드와 백엔드를 나눠서 관리하기로 한 이유는 몇 가지가 있습니다      역할 분리: 보통 프론트엔드와 백엔드를 각각 다른 사람이 맡아서 작업하는 경우가 많습니다. 따로 나눠두면 각자 맡은 부분만 신경 쓰면 되니까 작업도 훨씬 수월해집니다. 배포할 때도 각각 관리할 수 있어서 훨씬 유리합니다.        Docker 사용의 편리함: 통합 환경에서는 Docker를 도입할 때 어려움이 있었습니다. 개발할 때는 잘 돌아가는데, 컨테이너 안에서 실행하려고 하면 환경이 충돌하거나 제대로 작동하지 않는 경우가 많았습니다. 그래서 프론트와 백엔드를 따로 나누고, Docker 컨테이너로 분리해서 각각 관리할 수 있게 만들었습니다.  프로젝트 구조├─📂.gradle├─📂.idea├─📂backend│  ├─📂build│  ├─📂src│  │   ├─📂main│  │   └─📂test│  ├─📜Dockerfile│  └─📜build.gradle├─📂frontend│  ├─📂node_module│  ├─📂public│  ├─📂src│  ├─📜Dockerfile│  └─📜package.json├─📂bin├─📂gradle├─📂wrapper├─📜docer-compose.yml└─📜.env      백엔드: Spring Boot로 작성한 백엔드 부분은 ./backend 폴더에 있습니다. Dockerfile을 사용해 이 애플리케이션을 컨테이너로 빌드할 수 있도록 설정해두었습니다.        프론트엔드: React로 만든 프론트엔드는 ./frontend 폴더에 있고, 마찬가지로 Docker로 빌드해서 백엔드와는 독립적으로 실행됩니다.        Docker Compose: docker-compose.yml 파일로 MySQL, 프론트엔드, 백엔드를 한꺼번에 실행할 수 있게 했습니다. 각 서비스는 컨테이너로 나눠서 동작하고, 서로 통신할 수 있게 네트워크도 설정해두었습니다.  프로젝트 빌드 및 Dockerfile 작성백엔드 DockerfileFROM openjdk:17-jdk-alpineWORKDIR /srcCMD [\"./gradlew\", \"clean\", \"build\"]COPY build/libs/backend-0.0.1-SNAPSHOT.jar app.jarEXPOSE 8080ENTRYPOINT [\"java\",\"-jar\",\"./app.jar\"]프론트엔드 DockerfileFROM node:18-alpineWORKDIR /srcCOPY package.json .RUN npm installCOPY . .EXPOSE 3000CMD [ \"npm\", \"start\" ]Docker Compose 설정Docker Compose를 사용하여 전체 애플리케이션을 한꺼번에 실행할 수 있도록 하였습니다. 이 설정 파일을 통해 MySQL, 프론트엔드, 백엔드를 각각의 컨테이너에서 관리합니다.services:  db:    image: mysql:8.0.36    volumes:      - ./db_data:/var/lib/mysql    ports:      - \"3307:3306\"    environment:      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}      MYSQL_DATABASE: ${MYSQL_DATABASE}      MYSQL_USER: ${MYSQL_USER}      MYSQL_PASSWORD: ${MYSQL_PASSWORD}    healthcheck:      test: [ \"CMD\", \"mysqladmin\" ,\"ping\", \"-h\", \"contenthub-db-1\" ]      interval: 3s      timeout: 20s      retries: 10    networks:      - network  frontend:    build:      context: ./frontend      dockerfile: Dockerfile    container_name: contenthub-frontend    ports:      - \"3000:3000\"    networks:      - network  backend:    build:      context: ./backend      dockerfile: Dockerfile    container_name: contenthub-backend    ports:      - \"8080:8080\"    depends_on:      - db    environment:      SPRING_DATASOURCE_URL: ${SPRING_DATASOURCE_URL}      SPRING_DATASOURCE_USERNAME: ${SPRING_DATASOURCE_USERNAME}      SPRING_DATASOURCE_PASSWORD: ${SPRING_DATASOURCE_PASSWORD}    networks:      - networknetworks:  network:    driver: bridge중요한 설정 값들은 .env 파일을 이용해서 관리하고 있습니다.Docker Compose 실행Docker Compose를 사용해 애플리케이션을 실행할 때는 docker-compose up --build 명령어를 사용합니다. 이 명령어는 docker-compose.yml 파일에 정의된 서비스에 맞게 이미지를 생성한 후, 컨테이너를 실행합니다. 만약 이미지를 다시 빌드하고 싶다면 이 명령어를 사용하면 됩니다.docker-compose up --build이 명령어는 변경 사항이 있을 때 유용하게 사용할 수 있습니다.컨테이너를 중지하고 모든 자원을 정리하고 싶다면 docker-compose down 명령어를 사용하면 됩니다. 이 명령어는 실행 중인 컨테이너를 중지하고, 생성된 네트워크와 볼륨을 삭제합니다.docker-compose downMySQL 설정 및 데이터베이스 연결MySQL 도커 연결 문제1. Ports are not available 에러: 포트 중복 문제Ports are not available: exposing port TCP 0.0.0.0:3306 -&gt; 0.0.0.0:0: listen tcp 0.0 .0.0:3306: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.이미 포트 3306이 사용 중이어서 문제가 발생했습니다. 로컬에서 MySQL Workbench를 이용하며 진행하는 중 도커와 MySQL 간의 연결 시 3306 포트 충돌이 발생한 것입니다.      해결 방법Docker Compose에서 MySQL 도커 실행 명령어에서 다른 포트를 사용하도록 변경해주었습니다.    ports:  - \"3307:3306\"  # 호스트의 3307 포트를 컨테이너의 3306 포트로 매핑      2. access denied for user 에러 : 권한 문제access denied for user 'root'@'localhost' (using password: yes)MySQL에 로그인할 때 잘못된 비밀번호를 사용했거나 환경 변수 설정에서 문제가 발생합니다.  해결 방법docker-compose.yml 파일에서 도커 컨테이너 시작 시 비밀번호가 올바르게 설정되었는지 확인해야 합니다.    environment:  MYSQL_ROOT_PASSWORD: your_password        저는 MySQL Workbench의 비밀번호와 혼동하여 발생한 문제였습니다.    혹시 몰라서 docker exec -it your_mysql_container mysql -u root -p 명령어로 MySQL에 접속한 후 비밀번호를 설정해주었습니다.    ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password';      3. Communications link failure: 연결 문제com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure &lt;/n&gt; The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. MySQL 서버에 연결할 수 없을 때 발생하는 에러입니다. MySQL 서버가 실행 중이지 않거나 잘못된 네트워크 설정으로 인해 접근할 수 없는 경우입니다.      해결 방법spring.datasource.url=${SPRING_DATASOURCE_URL}에서 일반적으로 로컬 환경에서는 jdbc:mysql://localhost:3306/데이터베이스명?serverTimezone=UTC&amp;characterEncoding=UTF-8로 설정하지만, 도커를 이용할 경우엔 localhost를 MySQL 도커 컨테이너 이름으로 바꾸어야 합니다.    추가로 useSSL=false&amp;allowPublicKeyRetrieval=true 설정을 더했습니다.  4. react와 500에러위의 1~3번 에러를 해결한 후에는 데이터베이스와 서버 간의 연결 오류는 발생하지 않았습니다. 하지만, React에서 500 에러가 발생했습니다.  해결 방법package.json에서 프록시 설정을 변경해줘야합니다.      \"proxy\": \"http://backend:8080\",        localhost를 도커 서비스명으로 설정해야 합니다.  "
  },
  
  {
    "title": "자료구조 기초 정리",
    "url": "/posts/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/",
    "categories": "Programming, Data Structures",
    "tags": "data structures, algorithms, java",
    "date": "2024-09-11 12:33:00 +0900",
    





    
    "snippet": "자료구조란?자료구조는 데이터를 효율적으로 저장하고 관리하는 방법입니다. 우리가 프로그래밍할 때 데이터가 많아지면, 데이터를 어떻게 관리하느냐에 따라 프로그램의 성능이 크게 달라집니다. 그래서 데이터를 잘 정리하고, 필요한 정보를 빠르게 찾을 수 있도록 하는 것이 자료구조의 역할입니다. 배열, 스택, 큐, 트리 같은 것들이 자료구조에 속합니다.자료구조를...",
    "content": "자료구조란?자료구조는 데이터를 효율적으로 저장하고 관리하는 방법입니다. 우리가 프로그래밍할 때 데이터가 많아지면, 데이터를 어떻게 관리하느냐에 따라 프로그램의 성능이 크게 달라집니다. 그래서 데이터를 잘 정리하고, 필요한 정보를 빠르게 찾을 수 있도록 하는 것이 자료구조의 역할입니다. 배열, 스택, 큐, 트리 같은 것들이 자료구조에 속합니다.자료구조를 배워야하는 이유자료구조를 배우는 이유는, 코드를 더 효율적으로 짜기 위해서입니다. 데이터를 다루는 방법을 잘 알면, 프로그램의 속도를 빠르게 만들 수 있고, 메모리도 아낄 수 있습니다. 예를 들어, 어떤 자료구조를 쓰느냐에 따라 데이터를 찾거나, 추가하거나, 삭제하는 데 걸리는 시간이 크게 달라질 수 있습니다.자료구조의 종류배열(Array)배열은 데이터를 연속된 메모리 공간에 저장하는 자료구조로, 고정된 크기를 미리 설정하여 사용합니다.  연속적인 메모리 : 메모리 상에 연속적으로 배치됩니다. 이는 논리적 저장 위치와 물리적 저장 위치가 일치한다는 의미로, 각 원소는 인덱스를 통해 직접 접근이 가능합니다.  고정된 크기 : 배열 선언 시 크기를 정해야 하며, 이후에는 변경할 수 없습니다. 이로 인해 메모리 크기보다 데이터의 크기가 작을 경우 메모리 낭비가 발생할 수 있습니다.  시간복잡도          탐색(Access) : 인덱스를 사용하여 원소에 접근할 수 있기 때문에 O(1)의 시간 복잡도를 가집니다. 인덱스를 모르는 경우, 모든 원소를 확인해야 하므로 O(n)의 시간 복잡도가 소요됩니다.      삽입 및 삭제 (Insertion and Deletion): 배열의 끝에서 원소를 추가하거나 삭제하는 경우는 O(1)의 시간 복잡도를 가지지만, 배열의 중간에 원소를 삽입하거나 삭제할 때는 해당 위치 이후의 모든 원소를 이동시켜야 하므로 O(n)의 시간이 소요됩니다.      -&gt; 메모리 크기보다 더 큰 데이터를 저장시켜야될 경우엔?연결리스트(Linked List)연결 리스트는 노드라는 구조체를 사용하여 비연속적인 메모리 공간에 데이터를 저장하는 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 포인터(주소)를 포함합니다.  비연속적인 메모리 : 노드들은 메모리 상에 연속적으로 저장되지 않습니다. 각 노드는 메모리의 다른 위치에 저장되며, 다음 노드를 가리키는 포인터를 통해 연결됩니다.  가변적인 크기 : 연결 리스트는 동적으로 크기를 조절할 수 있습니다. 데이터가 추가되거나 삭제될 때 메모리의 재할당이 필요 없으며, 노드가 추가될 때마다 메모리가 동적으로 할당됩니다.  시간복잡도          탐색(Access) : 노드들이 메모리 상에 비연속적으로 저장되기 때문에, 특정 인덱스의 원소에 접근하려면 처음부터 순차적으로 탐색해야 합니다. 이로 인해 O(n)의 시간 복잡도를 가집니다.      삽입 및 삭제 (Insertion and Deletion): 노드를 추가하거나 삭제할 때는 해당 노드의 포인터만 변경하면 되므로, 인접한 노드의 포인터만 수정하면 됩니다. 따라서 O(1)의 시간 복잡도를 가집니다. 단, 특정 위치에 삽입하거나 삭제하려면 해당 위치까지 탐색해야 하므로, 탐색을 포함할 경우 O(n)이 될 수 있습니다.      스택(Stack)스택은 후입선출(LIFO) 방식으로 데이터를 관리하는 자료구조입니다.  연산          push : 데이터 삽입      pop : 데이터 삭제      peek : 맨 위의 데이터 확인(제거x)        사용사례 : 스택은 최근에 추가된 데이터를 먼저 처리해야 하는 상황에서 유용합니다. 데이터의 순서가 중요하거나, 최신 상태를 빠르게 확인하고 싶을 때 사용됩니다.ex) 함수 호출 시의 호출 스택 관리, 웹 브라우저의 뒤로 가기 기능, 수식 계산기 등큐(Queue)큐는 선입선출(FIFO) 방식으로 데이터를 관리하는 자료구조입니다.  연산          enqueue : 데이터 삽입      dequeue : 데이터 삭제      peek : 맨 위의 데이터 확인(제거x)        사용사례 : 큐는 먼저 들어온 데이터를 먼저 처리해야 하는 상황에서 유용합니다. 데이터의 순서가 중요하거나, 순서대로 처리가 필요할 때 사용됩니다. ex) 프린터 작업 예약, 운영 체제의 작업 스케줄링, 너비 우선 탐색(BFS) 알고리즘 등트리(Tree)트리는 부모와 자식 노드로 이루어진 계층적 자료구조입니다. 루트 노드에서 시작해 여러 자식 노드로 확장되며, 노드 간에 순환이 없는 특징이 있습니다.  계층 구조 : 상위 노드에서 하위 노드로 연결되는 구조로, 부모-자식 관계를 가집니다.  비순환 구조 : 트리는 노드들이 한 방향으로만 연결되며, 순환이 발생하지 않습니다.  사용사례 : 트리는 데이터 간의 계층적 관계를 표현하는 데 유용하게 사용됩니다. 예를 들어, 파일 시스템에서는 폴더와 파일의 계층 구조를 나타내는 데 사용됩니다. 또한, 이진 탐색 트리는 데이터의 효율적인 검색과 정렬을 가능하게 하며, AVL 트리와 레드-블랙 트리는 균형을 유지하여 삽입과 삭제 시 성능을 보장합니다.그래프(Graph)그래프는 여러 개의 노드와 그 노드들 간의 연결로 구성된 자료구조입니다. 각 노드는 여러 방향으로 노드와 연결할 수 있습니다.  여러 개의 연결어떻게 수정하지 : 각 노드는 다른 여러 노드와 연결될 수 있습니다. 방향성이 있을 수도, 없을 수도 있습니다.  순환 구조 : 같은 노드를 다시 방문하는 경로가 존재할 수 있습니다.  사용사례 : 그래프는 다양한 시스템에서 노드 간의 관계를 모델링하는 데 사용됩니다. 예를 들어, 소셜 네트워크에서는 사용자 간의 관계를 표현하고, 지도에서는 도시나 장소 간의 최단 경로를 계산하는 데 활용됩니다. 또한, 컴퓨터 네트워크나 통신 네트워크의 연결 상태를 분석하는 데에도 사용됩니다.해시그래프(Hash Table)해시 테이블은 데이터를 Key와 Value 쌍으로 저장하는 자료구조입니다. 각 Key는 해시 함수를 통해 고유한 해시 값으로 변환되어, 이 값을 기반으로 테이블의 인덱스에 데이터를 저장합니다.  빠른 접근 속도 : 해시 테이블은 해시 함수를 사용해 Key를 특정 인덱스에 매핑하기 때문에, 데이터를 직접적으로 접근할 수 있어 평균적으로 O(1)의 시간 복잡도를 가집니다. 해시 함수 덕분에 대규모 데이터에서 특정 값을 검색할 때도 효율적입니다.  충돌 해결 : 서로 다른 키가 동일한 해시 값을 가질 때는 충돌이 발생할 수 있으며, 이를 해결하기 위한 방법으로 체이닝이나 개방 주소법이 사용됩니다.  사용사례 : 해시 테이블은 데이터베이스에서 키-값 쌍을 빠르게 조회할 때, 캐시 시스템에서 자주 사용하는 데이터를 저장할 때, 또는 중복 확인과 같은 검색 작업에서 널리 사용됩니다."
  },
  
  {
    "title": "Spring Security로 JWT 기반 소셜 로그인 구현하기",
    "url": "/posts/security-jwt-login/",
    "categories": "Programming, Spring Security",
    "tags": "spring, java, security, jwt",
    "date": "2024-08-28 12:33:00 +0900",
    





    
    "snippet": "Spring Security의 보안 필터 체인Spring Security에서 필터 체인은 웹 애플리케이션의 요청(Request)과 응답(Response)을 처리하기 위해 사용하는 여러 필터의 연속입니다. 필터는 요청이 서버에 도달하기 전에 또는 응답이 클라이언트로 가기 전에 보안 검사를 하고, 필요에 따라 작업을 합니다.Spring Security의 ...",
    "content": "Spring Security의 보안 필터 체인Spring Security에서 필터 체인은 웹 애플리케이션의 요청(Request)과 응답(Response)을 처리하기 위해 사용하는 여러 필터의 연속입니다. 필터는 요청이 서버에 도달하기 전에 또는 응답이 클라이언트로 가기 전에 보안 검사를 하고, 필요에 따라 작업을 합니다.Spring Security의 주요 보안 필터들  UsernamePasswordAuthenticationFilter: 사용자가 로그인할 때 아이디와 비밀번호를 확인합니다.  SecurityContextPersistenceFilter: 사용자의 인증 정보를 세션에 저장하여 로그인 상태를 유지합니다.  CsrfFilter: CSRF 공격을 방지하기 위해 웹 폼의 보안을 강화합니다.  ExceptionTranslationFilter: 인증 오류나 접근 거부 상황을 처리합니다.  FilterSecurityInterceptor: 사용자가 요청한 리소스에 대한 접근 권한을 확인합니다.JWT 기반 소셜 로그인 구현하기SecurityConfig 클래스JWT 기반 소셜 로그인을 구현하려면, Spring Security의 기본 설정을 커스터마이징할 필요가 있습니다. 이 역할을 하는 것이 바로 SecurityConfig 클래스입니다.SecurityConfig 클래스는 Spring Security 설정을 정의하는 중심 클래스입니다. 이 클래스에서는 보안 필터 체인의 구성, 인증 및 인가 전략 설정, 그리고 예외 처리 등의 보안 관련 설정을 커스터마이징합니다.주요 설정들  필터 체인 설정          SecurityConfig 클래스에서 직접 필터들을 등록하고, 순서를 지정하여 필터 체인을 구성합니다. JwtAuthenticationFilter와 JwtAuthorizationFilter가 필터 체인에 추가해서 사용자가 로그인할 때 JWT 토큰을 생성하고, 이후 요청에서 토큰을 검증하는 로직이 필터 체인에 포함됩니다.        인증 및 인가 설정          특정 URL 패턴에 대한 접근 권한을 설정하고, 인증이 필요한 페이지와 그렇지 않은 페이지를 구분합니다.        로그인 설정          로그인 페이지, 로그인 성공 및 실패 처리, 로그아웃 설정 등을 정의합니다. 예를 들어, /login 경로를 로그인 페이지로 지정하고, 로그인 성공 시 JWT 토큰을 발급하는 로직을 추가할 수 있습니다.        예외 처리          인증 실패 시나 접근이 거부될 때의 예외 처리를 설정합니다.      SecurityConfig 클래스이제 SecurityConfig 클래스를 통해 JWT 인증 및 인가를 포함한 Spring Security 설정을 완성할 수 있습니다. 이 설정은 전체 보안 체계를 정의하는 중요한 역할을 하며, 애플리케이션의 보안을 탄탄하게 만듭니다.@EnableWebSecurity // Spring Security filter가 spring filterchain에 등록@EnableGlobalMethodSecurity(securedEnabled = true)public class SecurityConfig {    private final CorsFilter corsFilter;    private final PrincipalDetailsService principalDetailsService;    private final UserRepository userRepository;    private final TokenProvider tokenProvider;    @Value(\"${jwt.secret.key}\")    private String SECRET_KEY;    // 사용자가 제공한 비밀번호를 암호화하여 저장하고, 인증 시 저장된 비밀번호와 사용자가 제공한 비밀번호를 비교하여 일치 여부를 확인    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }    @Bean    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {        AuthenticationManagerBuilder sharedObject = http.getSharedObject(AuthenticationManagerBuilder.class);        sharedObject.userDetailsService(this.principalDetailsService);        AuthenticationManager authenticationManager = sharedObject.build();        http.authenticationManager(authenticationManager);        http.csrf(CsrfConfigurer::disable)                .httpBasic(httpBasic -&gt; httpBasic.disable())                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))                .addFilter(corsFilter) // 1. 컨트롤러에 @CrossOrigin 하는 방법 - 인증 X, 2. 시큐리티 필터에 등록 - 인증O                .addFilter(new JwtAuthenticationFilter(authenticationManager, tokenProvider))                .addFilter(                        new JwtAuthorizationFilter(authenticationManager, userRepository, tokenProvider, SECRET_KEY));        http.sessionManagement( // JWT 방식은 세션저장을 사용하지 않기 때문에 꺼주기.                sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));        http.authorizeHttpRequests(authorize -&gt; authorize                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")                .requestMatchers(\"/manager/**\").hasAnyRole(\"ADMIN\", \"MANAGER\") // 인증뿐만 아니라 권한이 있는 사람만 들어올 수 있다.                .requestMatchers(\"/user/**\").authenticated() // 해당 주소로 들어오면 인증이 필요하다.                .anyRequest().permitAll());        http.formLogin(formLogin -&gt; formLogin                .loginPage(\"/login\")                .usernameParameter(\"username\")                .passwordParameter(\"password\")                .loginProcessingUrl(\"/auth/login\") // 주소가 호출되면 시큐리티가 낚아채서 대신 로그인 진행                .permitAll());        http.logout(logout -&gt; logout                .permitAll());        //        return http.build();    }    @Bean    public CorsConfigurationSource corsConfigurationSource() {        CorsConfiguration config = new CorsConfiguration();        config.addAllowedOrigin(\"http://localhost:3000\");        config.addAllowedHeader(\"*\");        config.addAllowedMethod(\"*\");        config.setAllowCredentials(true);        // exposed-headers 설정        config.setExposedHeaders(Arrays.asList(\"Access-Control-Allow-Headers\",                \"Authorization, x-xsrf-token, Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, \" +                        \"Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers\"));        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(\"/**\", config);        return source;    }}JwtAuthenticationFilter 클래스이 필터는 사용자의 로그인 요청을 처리합니다. 사용자가 로그인 시도를 하면, 이 필터가 사용자의 자격 증명을 확인하고, 인증이 성공하면 JWT 토큰을 생성하여 응답에 포함시킵니다. JWT 토큰은 이후 요청에서 사용자의 인증 상태를 확인하는 데 사용됩니다.public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {    private final AuthenticationManager authenticationManager;    private final TokenProvider tokenProvider;    // 로그인 시도 시 실행되는 함수    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)            throws AuthenticationException {        log.info(\"JwtAuthenticationFilter : 로그인 시도 중\");        try {            ObjectMapper om = new ObjectMapper();            User user = om.readValue(request.getInputStream(), User.class);            // 사용자 이름과 비밀번호로 인증 토큰 생성            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(                    user.getUsername(), user.getPassword());            // 인증 시도 및 결과 반환            Authentication authentication = authenticationManager.authenticate(authenticationToken);            log.info(\"토큰 생성 완료!\");            return authentication;        } catch (IOException e) {            e.printStackTrace();        }        return null;    }    // 인증 성공 시 JWT 토큰 생성 및 응답 헤더에 추가    @Override    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,            Authentication authResult) throws IOException, ServletException {        log.info(\"JWT 토큰 생성\");        PrincipalDetails principalDetails = (PrincipalDetails) authResult.getPrincipal();        String jwtToken = tokenProvider.generateToken(principalDetails);        response.addHeader(\"Authorization\", \"Bearer \" + jwtToken);    }}JwtAuthorizationFilter 클래스이 필터는 사용자가 요청한 리소스에 접근할 권한이 있는지를 확인합니다. 사용자가 요청을 보낼 때, 요청 헤더에 포함된 JWT 토큰을 검증해 사용자가 유효한지 확인합니다. 만약 토큰이 유효하다면, 사용자의 권한을 체크하고 요청을 처리하도록 허용합니다.public class JwtAuthorizationFilter extends BasicAuthenticationFilter {    private final UserRepository userRepository;    private final String key;    private final TokenProvider tokenProvider;    public JwtAuthorizationFilter(AuthenticationManager authenticationManager, UserRepository userRepository,            TokenProvider tokenProvider, String key) {        super(authenticationManager);        this.userRepository = userRepository;        this.tokenProvider = tokenProvider;        this.key = key;    }    // 인증이나 권한이 필요한 주소 요청이 있을 때 해당 필터를 타게 됨    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)            throws IOException, ServletException {        log.info(\"인증이나 권한이 필요한 주소 요청이 됨\");        String jwtHeader = request.getHeader(\"Authorization\");        log.info(\"jwtHeader : \" + jwtHeader);        // header가 있는지 확인        if (jwtHeader == null || !jwtHeader.startsWith(\"Bearer\")) {            chain.doFilter(request, response);            return;        }        // JWT 토큰을 검증을 해서 정상적인 사용자인지 확인        String jwtToken = request.getHeader(\"Authorization\").replace(\"Bearer \", \"\");        if (jwtToken.equals(\"null\")) {            throw UserException.invalidUserException();        }        log.info(\"JwtAuthorizationFilter 키 확인 :  \" + key);        String username = tokenProvider.getUsernameFromToken(jwtToken);        // 서명이 정상적으로 됨        if (username != null) {            User userEntity = userRepository.findByUsername(username);            PrincipalDetails principalDetails = new PrincipalDetails(userEntity);            log.info(\"User roles: \" + userEntity.getRole()); // 권한 출력            // 이미 username으로 사용자가 인증됐기 때문에 강제로 authentication 만드는 중            // 비밀번호를 안넣고 null을 넣어도 상관없다.            Authentication authentication = new UsernamePasswordAuthenticationToken(principalDetails, null,                    principalDetails.getAuthorities());            // 강제로 시큐리티의 세션에 접근하여 Authentication 객체를 저장            SecurityContextHolder.getContext().setAuthentication(authentication);        }        chain.doFilter(request, response);    }}"
  },
  
  {
    "title": "Spring Security 인증 요청 처리 과정",
    "url": "/posts/spring-security/",
    "categories": "Programming, React, Spring",
    "tags": "jwt, spring, java, react, javascript, web, security",
    "date": "2024-08-21 10:00:00 +0900",
    





    
    "snippet": "Spring Security란?Spring Security는 Java 애플리케이션에서 보안을 관리하는 데 도움을 주는 프레임워크입니다. 주로 인증과 권한 부여를 처리하는 데 사용됩니다. 인증은 사용자가 누구인지 확인하는 과정이고, 권한 부여는 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 과정입니다.      인증(Autentication) : 사...",
    "content": "Spring Security란?Spring Security는 Java 애플리케이션에서 보안을 관리하는 데 도움을 주는 프레임워크입니다. 주로 인증과 권한 부여를 처리하는 데 사용됩니다. 인증은 사용자가 누구인지 확인하는 과정이고, 권한 부여는 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 과정입니다.      인증(Autentication) : 사용자가 로그인할 때, Spring Security는 사용자가 누구인지 확인합니다. 예를 들어, 아이디와 비밀번호를 입력하면, 이 정보를 바탕으로 사용자가 올바른지 검증합니다.        권한 부여(Authorization) : 사용자가 인증된 후, 어떤 자원이나 기능에 접근할 수 있는지를 결정합니다. 예를 들어, 관리자만 접근할 수 있는 페이지가 있다면, Spring Security는 인증된 사용자의 권한을 확인하여 이 페이지에 접근할 수 있는지 결정합니다.  인증 처리 과정Spring Security는 사용자가 로그인할 때 인증을 처리하기 위해 여러 클래스를 순차적으로 사용합니다. 이 과정은 요청이 서버에 도착한 순간부터 사용자가 누구인지 확인하고, 인증된 정보를 안전하게 관리하는 흐름입니다. 이를 통해 애플리케이션은 사용자의 신원을 확실히 확인하고, 적절한 권한을 부여하여 보안을 유지합니다.아래는 Spring Security가 사용자의 인증을 처리하는 일반적인 흐름입니다.      사용자가 애플리케이션에 로그인하거나 보호된 리소스에 접근하려고 할 때 요청이 서버에 도착합니다.        Authentication Filter가 요청을 가로채어 인증이 필요한지 확인합니다.        인증이 필요한 경우, AuthenticationFilter는 요청을 AuthenticationManager에게 넘겨 실제 인증 작업을 처리하도록 합니다.        AuthenticationManager는 여러 AuthenticationProvider 중에서 적절한 것을 선택해 사용자의 자격 증명(예: 아이디와 비밀번호)을 검증합니다.        AuthenticationProvider는 사용자의 자격 증명을 검증하기 위해 UserDetailsService를 사용하여 데이터베이스나 다른 저장소에서 사용자 정보를 조회합니다.        인증이 성공하면, 인증된 사용자 정보는 SecurityContextHolder에 저장됩니다. 이 정보는 사용자의 인증 상태를 나타내며, 애플리케이션 전반에서 활용됩니다.        인증된 정보는 SecurityContextHolder를 통해 접근할 수 있으며, 애플리케이션의 다른 부분, 특히 Spring Controller에서 사용자의 권한을 확인하고 요청을 처리하는 데 사용됩니다.        인증이 완료된 후, SecurityContextHolder에 저장된 사용자 인증 정보는 Spring Security가 제공하는 다양한 기능에서 활용됩니다. 예를 들어, 애플리케이션 내의 접근 제어와 권한 부여에서 이 정보를 사용합니다.        사용자가 애플리케이션의 다른 보호된 리소스에 접근하려고 할 때, SecurityContextHolder에 저장된 인증 정보는 다시 AuthenticationFilter를 거쳐 확인됩니다. 이로 인해 사용자는 재인증 없이도 동일한 세션 내에서 계속해서 보호된 리소스에 접근할 수 있습니다.        최종적으로, 인증된 사용자에 대한 정보와 권한은 애플리케이션의 비즈니스 로직이나 프레젠테이션 계층에서 활용되며, 사용자에게 적절한 권한을 부여하고, 보호된 리소스에 대한 접근을 제어하는 데 사용됩니다.  spring security 내부 구조 흐름            클래스      역할                  SecurityContextHolder      인증 정보를 저장하고 관리하는 중심 역할을 담당합니다.              Authentication      사용자 인증 상태를 나타내며, 인증된 사용자의 정보를 포함합니다.              AuthenticationManager      다양한 인증 제공자를 관리하며, 인증 요청을 처리합니다.              AuthenticationProvider      특정 인증 논리를 처리하며, UserDetailsService를 통해 사용자 정보를 로드합니다.              UserDetailsService      사용자 정보를 로드하여 UserDetails 객체로 반환합니다.              PasswordEncoder      비밀번호를 인코딩하고, 비밀번호 검증을 수행합니다.              Security Filters      다양한 보안 기능을 처리합니다.      security Filter ChainSpring Security에서 요청이 들어올 때, 이 필터 체인을 통해 인증, 권한 검사, 세션 관리 등 다양한 보안 작업이 수행됩니다.인증된 상태에서의 요청 처리Spring Security에서 사용자가 성공적으로 인증되면, 그 정보는 SecurityContextHolder에 저장됩니다. 이 객체는 애플리케이션 전반에서 사용자의 인증 상태를 유지하는 데 중요한 역할을 합니다.그런데 이 과정에서 “사용자의 요청이 들어오면 Spring Security의 필터가 먼저 요청을 가로채서 처리한다고 하는데, 그러면 SecurityContextHolder는 언제 활용될까?”라는 생각이 들었습니다. 요청이 들어오자마자 SecurityContextHolder에서 인증 정보를 바로 꺼내 사용하는 걸까, 아니면 필터가 요청을 검토한 후에야 SecurityContextHolder가 사용되는 걸까?실제로는 요청이 들어올 때 필터가 SecurityContextHolder에 저장된 인증 정보를 먼저 확인합니다. 이 과정에서 필터는 해당 인증 정보가 유효한지 검토하고, 그에 따라 요청을 처리합니다. 이로 인해 동일한 세션 내에서는 반복적인 인증 절차 없이 사용자의 인증 상태를 유지할 수 있습니다. 그러나 필터는 여전히 세션 만료나 토큰 유효성 같은 상황을 확인하기 위해 요청을 재검토할 수 있습니다."
  },
  
  {
    "title": "JWT를 활용한 React와 Spring Boot의 인증 처리",
    "url": "/posts/jwt/",
    "categories": "Programming, React, Spring",
    "tags": "jwt, spring, java, react, javascript, web",
    "date": "2024-08-16 10:00:00 +0900",
    





    
    "snippet": "JWT(JSON Web Token)JWT는 토큰 기반의 인증 방식으로, 서버에서 클라이언트에게 JWT를 발급하고, 클라이언트는 이 토큰을 API 요청 시마다 서버에 전달하여 인증을 받는 방식입니다.Spring Boot에서 JWT 설정하기Spring Boot에서 JWT를 사용해 로그인과 회원가입을 처리하는 API를 구현한 부분입니다.@RestContro...",
    "content": "JWT(JSON Web Token)JWT는 토큰 기반의 인증 방식으로, 서버에서 클라이언트에게 JWT를 발급하고, 클라이언트는 이 토큰을 API 요청 시마다 서버에 전달하여 인증을 받는 방식입니다.Spring Boot에서 JWT 설정하기Spring Boot에서 JWT를 사용해 로그인과 회원가입을 처리하는 API를 구현한 부분입니다.@RestController@RequestMapping(\"/api/auth\")public class AuthController {        @PostMapping(\"/login\")    public ResponseEntity&lt;?&gt; authenticateUser(@RequestBody LoginRequest loginRequest) {        // 인증 로직 (username과 password 검증)        // JWT 생성        String jwt = jwtProvider.generateToken(loginRequest.getUsername());        return ResponseEntity.ok(new JwtResponse(jwt));    }    @PostMapping(\"/signup\")    public ResponseEntity&lt;String&gt; SignUp(@RequestBody User user) throws UserException {        try {            authService.saveUser(user);            return ResponseEntity.ok(\"유저 정보 저장 성공!!\");        } catch(UserException e) {            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());        }    }}authService에서는 사용자 정보를 검증하고 JWT를 생성합니다.public void saveUser(User user) throws UserException {    User existingUser = userRepository.findByUserName(user.getUserName());    if (existingUser != null) {        throw UserException.duplicateUserException();    }    userRepository.save(user);}public void loginUser(User user) throws UserException {    User existingUser = userRepository.findByUserNameAndUserPwd(user.getUserName(), user.getUserPwd());    if (existingUser == null) {        throw UserException.invalidUserException();    }}React에서 JWT로 API 호출하기React에서는 로그인 후 받은 JWT 토큰을 localStorage에 저장하고, 이후 API를 호출할 때마다 이 토큰을 헤더에 추가하는 방식으로 인증을 처리했습니다function login(username, password) {  axios.post('/api/auth/login', { username, password })    .then(response =&gt; {      localStorage.setItem('token', response.data.token);    })    .catch(error =&gt; {      console.error('Login error', error);    });}function fetchToken() {  const token = localStorage.getItem('token');  axios.get('/api/protected-resource', {    headers: {      'Authorization': `Bearer ${token}`    }  }).then(response =&gt; {    console.log(response.data);  }).catch(error =&gt; {    console.error('Fetching error', error);  });}문제  토큰 만료 처리 : 처음에는 토큰 만료 시 처리 방법에 대해 고민이 있었습니다. 최종적으로는 만료된 토큰으로 API 호출 시 서버에서 401 Unauthorized 응답을 받을 경우, 클라이언트에서 자동으로 로그아웃하고, localStorage에서 토큰을 삭제하는 방식으로 구현했습니다.const handleLogin = (event) =&gt; {  event.preventDefault();  // 사용자 정보를 객체로 생성  let user = {    userName: name,    userPwd: pwd,  };  // 로그인 API 호출  UserService.login(user)    .then((res) =&gt; {      localStorage.setItem(\"accessToken\", res.data.token);      navigate(`/`);    })    .catch((error) =&gt; {      if (error.response &amp;&amp; error.response.status === 401) {        window.alert(\"아이디나 비밀번호가 다릅니다.\");        localStorage.removeItem('accessToken');        navigate('/login');      } else {        console.log(\"Login error:\", error);        window.alert(\"로그인 중 오류가 발생했습니다.\");      }    });};  성공 처리 : 로그인에 성공하면, 응답에서 받은 JWT 토큰을 localStorage에 저장하고 메인 페이지로 리다이렉트합니다.  오류 처리          401 오류 처리 : 로그인 요청 시 401 Unauthorized 응답이 오면, window.alert로 에러 메시지를 보여주고, 저장된 토큰을 삭제한 후 로그인 페이지로 리다이렉트합니다.      기타 오류 : 다른 종류의 오류가 발생한 경우, 해당 오류를 콘솔에 기록하고 일반적인 에러 메시지를 보여줍니다.        고민                  보안 : JWT를 localStorage에 저장하는 것은 보안에 취약하다는 점을 알게 되었습니다. 이 문제는 다음 포스트에서 Spring Security를 활용하여 개선할 계획입니다.    Refresh Token : 리프레시 토큰을 사용하여 세션을 유지하는 방법도 고려했지만, 초기에는 리프레시 토큰을 관리하는 로직이 복잡하여 많은 시간을 소모했습니다. 현재는 토큰 만료 시 사용자에게 다시 로그인하도록 유도하는 방식으로 처리하고 있습니다."
  },
  
  {
    "title": "React와 Spring Boot의 REST API를 통한 데이터 통신",
    "url": "/posts/react-springBoot/",
    "categories": "Programming, React, Spring",
    "tags": "spring, java, react, javascript, web",
    "date": "2024-08-14 20:33:00 +0900",
    





    
    "snippet": "React와 Spring Boot 연동처음 React와 Spring Boot를 함께 사용하려고 할 때, 가장 먼저 떠오른 것은 “이 둘을 어떻게 연결할까?”였습니다. React는 프론트엔드 라이브러리로서, 주로 사용자 인터페이스를 만들 때 사용되고, Spring Boot는 백엔드 프레임워크로서 서버 측 로직을 처리합니다. 이 두 가지를 연결하는 방법 ...",
    "content": "React와 Spring Boot 연동처음 React와 Spring Boot를 함께 사용하려고 할 때, 가장 먼저 떠오른 것은 “이 둘을 어떻게 연결할까?”였습니다. React는 프론트엔드 라이브러리로서, 주로 사용자 인터페이스를 만들 때 사용되고, Spring Boot는 백엔드 프레임워크로서 서버 측 로직을 처리합니다. 이 두 가지를 연결하는 방법 중 가장 일반적인 방법은 REST API를 사용하는 것입니다.REST API는 클라이언트(React)와 서버(Spring Boot)가 서로 데이터를 주고받을 수 있도록 해주는 표준화된 인터페이스입니다. 서버에서 데이터를 제공하는 엔드포인트를 정의하고, 클라이언트는 이 엔드포인트를 호출하여 필요한 데이터를 가져오거나 서버에 데이터를 전송할 수 있습니다.Spring Boot에서 REST API 만들기예시) 간단한 유저 정보를 제공하는 API@RestController@RequestMapping(\"/api/users\")public class UserController {    @GetMapping(\"/{id}\")    public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) {        User user = userService.findById(id);        return ResponseEntity.ok(user);    }}이 코드에서 @RestController와 @GetMapping 어노테이션을 사용하여 /api/users/{id} 경로로 GET 요청이 들어오면, 해당 유저의 정보를 반환하는 API를 만들었습니다.React에서 API 호출하기이제 React에서 Spring Boot의 REST API를 호출해 데이터를 가져오는 방법을 설명하겠습니다. React에서 API를 호출할 때는 주로 fetch나 axios 같은 라이브러리를 사용합니다. 개인적으로는 axios가 더 편리해서 자주 사용하고 있습니다.아래는 axios를 사용하여 Spring Boot API에서 유저 정보를 가져오는 예제입니다.import React, { useState, useEffect } from 'react';import axios from 'axios';function UserInfo({ userId }) {  const [user, setUser] = useState(null);  useEffect(() =&gt; {    axios.get(`/api/users/${userId}`)      .then(response =&gt; {        setUser(response.data);      })      .catch(error =&gt; {        console.error('실패!', error);      });  }, [userId]);  if (!user) return &lt;div&gt;Loading...&lt;/div&gt;;  return (    &lt;div&gt;      &lt;h1&gt;{user.name}&lt;/h1&gt;      &lt;p&gt;Email: {user.email}&lt;/p&gt;    &lt;/div&gt;  );}export default UserInfo;이 코드에서는 useEffect를 사용해 컴포넌트가 렌더링될 때 API를 호출하고, 응답 데이터를 user 상태에 저장했습니다. user 상태가 null일 때는 Loading... 메시지를 표시하고, 데이터가 로드되면 유저의 이름과 이메일을 화면에 출력합니다."
  },
  
  {
    "title": "로그인 상태 관리 - React에서 데이터를 컴포넌트 간에 전달",
    "url": "/posts/react-state/",
    "categories": "Programming, React",
    "tags": "react, javascript, web",
    "date": "2024-08-10 20:33:00 +0900",
    





    
    "snippet": "React로 프로젝트를 진행하면서, 저는 주로 함수형 컴포넌트를 사용해왔습니다. 처음에는 useState 훅을 사용해 간단하게 상태를 관리할 수 있었지만, 여러 컴포넌트 간에 상태를 공유해야 할 때 복잡함이 증가하면서 어려움을 겪기도 했습니다. 특히, 로그인 기능이 포함된 애플리케이션에서 상태 관리가 점점 복잡해지기 시작했는데, 그 과정에서 여러 문제...",
    "content": "React로 프로젝트를 진행하면서, 저는 주로 함수형 컴포넌트를 사용해왔습니다. 처음에는 useState 훅을 사용해 간단하게 상태를 관리할 수 있었지만, 여러 컴포넌트 간에 상태를 공유해야 할 때 복잡함이 증가하면서 어려움을 겪기도 했습니다. 특히, 로그인 기능이 포함된 애플리케이션에서 상태 관리가 점점 복잡해지기 시작했는데, 그 과정에서 여러 문제에 직면했습니다.문제 상황로그인 기능을 구현할 때, 사용자가 로그인하면 해당 정보를 다른 컴포넌트에서도 표시해야 했습니다. 처음에는 로그인 컴포넌트에서 사용자 정보를 받아서 바로 다른 컴포넌트들(Home, MyPage 등)로 전달하려 했습니다. 하지만 이런 방식은 상태 관리가 점점 복잡해지면서, 특히 사용자 정보가 필요한 시점에 제대로 전달되지 않는 문제가 발생했습니다.문제 1 : 자식 컴포넌트 간 상태 전달처음에는 로그인 컴포넌트 내에서 useState를 사용해 유저의 로그인 상태와 닉네임을 관리했습니다. 로그인에 성공한 후, 이 상태를 다른 컴포넌트에 전달하기 위해 props를 통해 데이터를 주고받으려 했습니다. 그러나 자식 컴포넌트들 간에 직접 상태를 전달하는 방식은 유지보수나 확장성 측면에서 한계가 분명했습니다. 데이터 흐름이 복잡해지면서 상태가 여러 컴포넌트에 분산되었고, 이로 인해 코드가 이해하기 어려워졌습니다.해결책 1 : 상태를 부모 컴포넌트로 이동이 문제를 해결하기 위해, 상태를 최상위 부모 컴포넌트인 App으로 옮기고, 이 컴포넌트가 모든 상태를 관리하도록 구조를 변경했습니다. 이렇게 하니, 자식 컴포넌트들은 부모 컴포넌트로부터 필요한 데이터를 props로 받아 사용할 수 있었고, 데이터 흐름이 단순하고 명확해졌습니다.function App() {  const [loggedIn, setLoggedIn] = useState(false);  const [name, setName] = useState(\"\");  return (    &lt;Router&gt;      &lt;Routes&gt;      &lt;Route          path=\"/\"          element={            &lt;Home name={name} loggedIn={loggedIn} setLoggedIn={setLoggedIn} /&gt;          }        /&gt;        &lt;Route          path=\"/login\"          element={            &lt;LoginForm setLoggedIn={setLoggedIn} setUserName={setName} /&gt;          }        /&gt;      &lt;/Routes&gt;      &lt;Route element={&lt;PrivateRoute redirectPath=\"/login\"/&gt;} &gt;        &lt;Route path=\"/user\" element={&lt;MyPage /&gt;} /&gt;      &lt;/Route&gt;    &lt;/Router&gt;  );}문제 2 : Null 값 문제상태를 App 컴포넌트로 옮겨서 상태 전달은 훨씬 간단해졌지만, 컴포넌트에서 전달된 상태가 null로 나타나는 문제가 발생했습니다. 이는 상태가 아직 업데이트되기 전에 컴포넌트가 렌더링되면서 발생한 문제였습니다.해결책 2 : useOutletContext 활용이 문제를 해결하기 위해 React Router의 useOutletContext를 사용했습니다. useOutletContext는 부모 라우트에서 자식 컴포넌트로 데이터를 전달할 때 사용되는 훅입니다. 일반적으로 상태를 자식 컴포넌트에 props로 전달하거나, 전역 상태 관리 방법을 사용하는데, useOutletContext를 활용하면 중첩된 라우트 구조에서도 부모 컴포넌트에서 설정한 context를 자식 컴포넌트가 쉽게 접근할 수 있게 됩니다.이를 통해 부모 컴포넌트에서 관리하는 상태를 자식 컴포넌트로 보다 안정적으로 전달할 수 있었고, null 값 문제를 해결할 수 있었습니다.import React from \"react\";import { useOutletContext } from \"react-router-dom\";function MyPage() {  const userInfo = useOutletContext(); // 부모 라우트에서 전달된 데이터 사용  return (    &lt;div className=\"MyPage_container\"&gt;      {userInfo ? `${userInfo}님의 페이지입니다.` : \"유저 정보가 없습니다.\"}    &lt;/div&gt;  );}export default MyPage;useOutletContext와 props의 차이점      props : 일반적으로 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용하는 방법입니다. 부모 컴포넌트에서 자식 컴포넌트로 전달하려는 데이터를 명시적으로 설정하고, 그 데이터를 자식 컴포넌트의 props로 넘깁니다.        useOutletContext : React Router에서 사용하는 훅으로, 부모 라우트의 데이터를 하위 라우트에서 쉽게 접근할 수 있도록 해줍니다. 이는 여러 라우트 간에 데이터를 공유할 때 유용합니다.  props 사용 시 null문제가 발생하는 이유props를 사용할 때 null 문제가 발생하는 이유는 비동기 상태 업데이트 및 라우트 전환 시점과 관련이 있습니다:      비동기 상태 업데이트: useEffect와 같은 비동기 작업이 완료되기 전에 컴포넌트가 먼저 렌더링될 수 있습니다. 이 경우, 아직 상태가 업데이트되지 않아서 props로 전달되는 값이 null이 될 수 있습니다.        라우트 전환의 타이밍: 특정 라우트에서 다른 라우트로 이동할 때, 부모 컴포넌트가 아직 데이터를 준비하지 않은 상태에서 자식 컴포넌트가 렌더링될 수 있습니다. 이 경우, 자식 컴포넌트에서 props를 통해 받는 데이터가 null이 될 수 있습니다.  useOutletContext가 잘 동작하는 이유useOutletContext는 부모 라우트에서 데이터가 준비된 후에 자식 라우트에서 해당 데이터를 사용할 수 있도록 보장합니다. 이로 인해 null 문제가 발생하지 않으며, 다음과 같은 장점이 있습니다:      데이터 준비 타이밍: 부모 라우트에서 데이터가 준비된 후에 자식 라우트가 해당 데이터를 사용하게 되므로, 자식 라우트가 데이터 준비가 완료되지 않은 상태에서 렌더링되는 일이 줄어듭니다.        컨텍스트 기반 데이터 접근: useOutletContext는 React의 컨텍스트 API를 기반으로 하므로, 데이터가 필요한 모든 하위 라우트에서 일관되게 데이터를 접근할 수 있습니다. 이는 데이터 흐름이 보다 명확하고 안정적으로 이루어질 수 있게 해줍니다.        렌더링 순서 보장: useOutletContext는 React Router의 라우트 렌더링 순서에 의해 컨텍스트를 전달하므로, 부모 라우트의 데이터가 준비되기 전에 자식 라우트가 렌더링되는 일이 줄어듭니다.  느낀 점이렇게 두 가지 문제를 해결하면서, React에서 상태 관리를 어떻게 최적화하고 데이터 전달을 보다 명확하게 할 수 있는지 배웠습니다. 컴포넌트 간의 상태 전달은 처음에는 다소 헷갈릴 수 있지만, 구조를 잘 잡아 나가면서 점점 더 이해하기 쉬운 코드를 작성할 수 있었습니다."
  },
  
  {
    "title": "React의 기본 개념과 첫 컴포넌트 만들기",
    "url": "/posts/react/",
    "categories": "Programming, React",
    "tags": "react, javascript, web",
    "date": "2024-08-07 20:33:00 +0900",
    





    
    "snippet": "React의 기본 개념React는 자바스크립트로 작성된 라이브러리로, 사용자 인터페이스를 구축하는 데 사용됩니다. 컴포넌트 기반 아키텍처를 통해 UI를 작은 재사용 가능한 컴포넌트들로 나누어 관리할 수 있어, 복잡한 애플리케이션도 효율적으로 개발할 수 있습니다.주요 특징:      선언형 : UI의 상태에 따라 자동으로 업데이트가 이루어져 코드가 깔끔...",
    "content": "React의 기본 개념React는 자바스크립트로 작성된 라이브러리로, 사용자 인터페이스를 구축하는 데 사용됩니다. 컴포넌트 기반 아키텍처를 통해 UI를 작은 재사용 가능한 컴포넌트들로 나누어 관리할 수 있어, 복잡한 애플리케이션도 효율적으로 개발할 수 있습니다.주요 특징:      선언형 : UI의 상태에 따라 자동으로 업데이트가 이루어져 코드가 깔끔하고 관리하기 쉬워집니다.        컴포넌트 기반 : UI를 작은 컴포넌트로 나누어 재사용성과 유지보수를 쉽게 할 수 있습니다.        Virtual DOM : 가상 DOM을 사용해 변경 사항을 먼저 계산하고, 실제 DOM에 필요한 최소한의 업데이트만 적용하여 성능을 최적화합니다.  컴포넌트 기반 아키텍처React의 핵심은 컴포넌트입니다. 컴포넌트는 UI의 특정 부분을 관리하는 작은 블록으로, 각 컴포넌트는 자체적으로 상태를 가질 수 있고, 부모 컴포넌트로부터 props를 받아서 UI를 구성합니다.import React from 'react';function Welcome() {  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;}export default Welcome;JSXJSX는 자바스크립트 파일 안에서 HTML처럼 보이는 구문을 사용할 수 있게 해주는 문법입니다. JSX는 자바스크립트로 변환되어 브라우저가 이해할 수 있습니다.const element = &lt;h1&gt;Hello!&lt;/h1&gt;;JSX는 HTML과 비슷하지만, 몇 가지 중요한 차이점이 있습니다:      class 대신 className을 사용합니다.        자바스크립트 표현식을 사용하려면 중괄호 {}를 사용합니다.  함수형 컴포넌트와 클래스형 컴포넌트React에서는 두 가지 주요 컴포넌트 타입이 있습니다. 함수형 컴포넌트와 클래스형 컴포넌트입니다.함수형 컴포넌트함수형 컴포넌트는 props를 입력으로 받아 JSX를 반환합니다. 상태와 라이프사이클 관련 작업은 React 훅을 통해 처리합니다.import React, { useState } from 'react';function Counter() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;현재 카운트: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        카운트 증가      &lt;/button&gt;    &lt;/div&gt;  );}export default Counter;      간결한 문법 : 함수형 컴포넌트는 코드가 깔끔하고 직관적입니다.        훅 사용 : useState, useEffect 등 훅을 통해 상태 관리와 사이드 이펙트를 처리할 수 있습니다.        함수형 프로그래밍 : 불변성과 순수 함수를 지향합니다.  클래스형 컴포넌트클래스형 컴포넌트는 render() 메서드를 사용해 JSX를 반환하며, 상태와 라이프사이클 메서드를 직접 정의할 수 있습니다.import React, { Component } from 'react';class Counter extends Component {  constructor(props) {    super(props);    this.state = { count: 0 };  }  render() {    return (      &lt;div&gt;        &lt;p&gt;현재 카운트: {this.state.count}&lt;/p&gt;        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;          카운트 증가        &lt;/button&gt;      &lt;/div&gt;    );  }}export default Counter;      상태와 라이프사이클 메서드 : 상태 관리와 라이프사이클 메서드를 명시적으로 정의할 수 있습니다.        복잡한 로직 처리 : 상태와 라이프사이클 관리가 복잡할 때 유용합니다.        전통적인 방식 : React의 초창기에는 주로 사용되었지만, 현재는 함수형 컴포넌트와 훅이 선호됩니다.  State와 PropsReact에서 데이터를 관리하는 두 가지 주요 방법은 State와 Props입니다.      State : 컴포넌트 내에서 관리되는 데이터입니다. 상태는 시간이 지나면서 변할 수 있으며 UI에 영향을 미칩니다.        Props : 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 데이터입니다. Props는 읽기 전용이며 변경할 수 없습니다.  import React, { useState } from 'react';function Counter() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;현재 카운트: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        카운트 증가      &lt;/button&gt;    &lt;/div&gt;  );}export default Counter;위 코드에서는 useState 훅을 사용해 count 상태를 관리합니다. 버튼을 클릭하면 count 값이 증가하고, UI가 업데이트됩니다.실습간단하게 “Hello, World!”를 출력하는 컴포넌트를 만들어보겠습니다.import React from 'react';import ReactDOM from 'react-dom';import Welcome from './Welcome';ReactDOM.render(&lt;Welcome /&gt;, document.getElementById('root'));이 코드는 React의 ReactDOM.render를 사용해 Welcome 컴포넌트를 root 요소에 렌더링합니다."
  },
  
  {
    "title": "멀티스레드 환경에서의 싱글톤 패턴 적용 경험",
    "url": "/posts/singleton-multithread/",
    "categories": "Programming, Design Patterns",
    "tags": "java, singleton",
    "date": "2024-07-31 20:33:00 +0900",
    





    
    "snippet": "서버 애플리케이션을 개발하면서 특정 클래스의 인스턴스를 한 번만 생성하고 여러 클래스에서 사용할 필요가 있었습니다. 처음에는 의존성 주입을 통해 이를 해결했지만, 여러 클래스에 걸쳐 인스턴스를 넘겨주다 보니 코드가 복잡해졌습니다. 그래서 싱글톤 패턴을 적용해 보기로 했습니다. 그러나, 멀티스레드 환경에서 예상치 못한 문제가 발생하여 결국 다시 의존성 ...",
    "content": "서버 애플리케이션을 개발하면서 특정 클래스의 인스턴스를 한 번만 생성하고 여러 클래스에서 사용할 필요가 있었습니다. 처음에는 의존성 주입을 통해 이를 해결했지만, 여러 클래스에 걸쳐 인스턴스를 넘겨주다 보니 코드가 복잡해졌습니다. 그래서 싱글톤 패턴을 적용해 보기로 했습니다. 그러나, 멀티스레드 환경에서 예상치 못한 문제가 발생하여 결국 다시 의존성 주입으로 돌아가게 되었습니다.문제 상황서버 애플리케이션에는 사용자 관리 및 메시지 브로드캐스트를 관리하는 UserManager 클래스가 있었습니다. 이 클래스는 여러 곳에서 공유되어야 했습니다. 처음에는 UserManager 인스턴스를 메인 서버 클래스에서 생성한 후, 소켓 연결 클래스, 클라이언트 연결 클래스, 유저 스레드 등 여러 곳에 의존성 주입을 통해 넘겨주었습니다. 각 클래스에 인스턴스를 넘겨주는 과정이 복잡하고 번거로웠습니다.public class JavaGameServer extends JFrame {\tpublic static void main(String[] args) {        ServerWindow serverUI = new ServerWindow();        serverUI.setVisible(true);        UserManager userManager = new UserManager(); //해당         ServerSocketHandler serverSocketHandler = new ServerSocketHandler(serverUI, userManager);        serverUI.setServerSocketHandler(serverSocketHandler);\t}}이 접근 방식은 시간이 지나면서 코드가 점점 복잡해졌습니다. 인스턴스를 여러 클래스에 넘겨주는 과정이 번거로웠고, 유지보수가 어려웠습니다. 인스턴스를 넘겨주는 과정에서 코드가 복잡해지기 때문에 이를 단순화하기 위해 싱글톤 패턴을 적용하기로 했습니다.싱글톤 패턴 적용싱글톤 패턴을 적용하여 UserManager 클래스를 단 하나의 인스턴스로 관리하려 했습니다.public class UserManager {    private static UserManager instance;    private UserManager() {}    public static UserManager getInstance() {        if (instance == null) {            instance = new UserManager();        }        return instance;    }    //...}그리고 필요한 곳에서 UserManager.getInstance()를 호출하여 인스턴스를 사용하도록 했습니다.발생한 문제싱글톤 패턴을 적용한 후, 서버를 실행해 보니 하나의 유저만 제대로 작동하고 나머지 유저는 전혀 실행되지 않는 문제가 발생했습니다. 이 문제는 멀티스레드 환경에서 UserManager 인스턴스를 생성하는 과정에서 여러 스레드가 동시에 접근하면서 발생한 것으로 추측되었습니다. UserManager의 인스턴스가 제대로 초기화되지 않아, 두 번째 유저부터는 실행조차 되지 않는 상황이었습니다.문제 해결 시도문제를 해결하기 위해 synchronized 키워드를 사용해 보았습니다.public static synchronized UserManager getInstance() {        if (instance == null) {            instance = new UserManager();        }        return instance;    }그러나, 이 변경 후에도 여전히 문제가 해결되지 않았고, 여러 유저가 동시에 접근하는 상황에서 UserManager의 인스턴스가 제대로 생성되지 않는 문제는 여전히 발생했습니다. 이로 인해 멀티스레드 환경에서 싱글톤 패턴이 예상대로 동작하지 않는다는 것을 확인했습니다.결론결국, 싱글톤 패턴을 포기하고 다시 의존성 주입 방식으로 돌아갔습니다. 의존성 주입 방식은 각 클래스에 UserManager 인스턴스를 직접 넘겨주는 방식으로, 멀티스레드 환경에서 안정적으로 작동했습니다. 이 경험을 통해, 특정 상황에서는 싱글톤 패턴이 아닌 다른 설계 방식이 더 적합할 수 있다는 것을 깨달았습니다. 이 경험을 통해, 디자인 패턴의 장단점을 잘 이해하고 상황에 맞게 적용하는 것이 중요하다는 것을 깨닫게 되었습니다."
  },
  
  {
    "title": "싱글톤 패턴(Singleton Pattern)",
    "url": "/posts/signleton/",
    "categories": "Programming, Design Patterns",
    "tags": "java, singleton",
    "date": "2024-07-29 20:33:00 +0900",
    





    
    "snippet": "싱글톤 패턴이란?싱글톤 패턴은 특정 클래스의 인스턴스를 하나만 생성하여 전역적으로 접근할 수 있도록 보장하는 디자인 패턴입니다. 예를 들어, 애플리케이션 설정을 하나의 중앙 객체로 관리하거나, 데이터베이스 연결을 단일 인스턴스로 유지하거나, 로그를 하나의 객체에서 처리해야 할 때 사용할 수 있습니다. 싱글톤 패턴을 통해 시스템 내에서 하나의 객체만 존...",
    "content": "싱글톤 패턴이란?싱글톤 패턴은 특정 클래스의 인스턴스를 하나만 생성하여 전역적으로 접근할 수 있도록 보장하는 디자인 패턴입니다. 예를 들어, 애플리케이션 설정을 하나의 중앙 객체로 관리하거나, 데이터베이스 연결을 단일 인스턴스로 유지하거나, 로그를 하나의 객체에서 처리해야 할 때 사용할 수 있습니다. 싱글톤 패턴을 통해 시스템 내에서 하나의 객체만 존재하게 하여 자원 낭비를 방지하고, 전역적으로 접근 가능한 객체를 제공할 수 있습니다.싱글톤 패턴을 사용하는 이유싱글톤 패턴의 특징      단일 인스턴스: 클래스의 인스턴스가 하나만 생성됩니다. 메모리 낭비를 줄이고 자원을 효율적으로 사용할 수 있습니다.        전역 접근: 프로그램 어디서든 인스턴스에 접근할 수 있습니다. 객체 지향적으로 접근할 수 있어 코드의 유지보수성과 가독성을 높입니다.  장단점장점:      인스턴스 생성 비용 절감 : 객체를 매번 새로 생성하지 않으므로 자원을 절약할 수 있습니다.        전역 상태 관리 : 애플리케이션 전반에 걸쳐 공유되는 자원이나 설정을 관리하기 쉽습니다.  단점:      테스트하기 어려움 : 싱글톤은 전역 상태를 유지하기 때문에 단위 테스트 작성이 어려울 수 있습니다. 객체가 전역적으로 접근 가능하므로 테스트 환경에서 상태를 초기화하거나 변경하는 데 어려움이 있습니다.        의존성 숨기기 가능성 : 싱글톤을 과도하게 사용하면 코드의 의존성을 명확하게 알기 어렵게 됩니다.  싱글톤 패턴 구현하기기본 구현싱글톤 패턴의 기본 구현은 클래스 내부에 인스턴스를 생성하고 이를 반환하는 방법입니다.public class Singleton {    // 클래스의 유일한 인스턴스를 저장할 정적 변수    private static Singleton instance;    // 생성자를 private으로 지정하여 외부에서 인스턴스 생성 불가    private Singleton() {}    // 클래스의 유일한 인스턴스를 반환하는 정적 메서드    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton(); // 인스턴스가 없다면 새로 생성        }        return instance; // 이미 있다면 기존 인스턴스 반환    }}위 구현은 단순하고 이해하기 쉽지만, 멀티스레드 환경에서는 문제가 발생할 수 있습니다. 여러 스레드가 동시에 getInstance() 메서드에 접근하면, 두 개 이상의 인스턴스가 생성될 수 있습니다.싱글톤 패턴의 문제점쓰레드 안전성멀티스레드 환경에서는 여러 스레드가 동시에 getInstance() 메서드에 접근하면, 두 개 이상의 인스턴스가 생성될 수 있습니다. 이를 방지하려면 쓰레드 안전성을 확보해야 합니다. 가장 간단한 방법은 synchronized 키워드를 사용하는 것입니다. synchronized 키워드를 사용하면 동시에 여러 스레드가 getInstance() 메서드에 접근하지 못하도록 막아줍니다.public class Singleton {    private static Singleton instance;    private Singleton() {}    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}이 방법은 쓰레드 안전성을 보장하지만, 매번 getInstance() 메서드를 호출할 때마다 synchronized 블록에 진입하기 때문에 성능에 영향을 미칠 수 있습니다. 인스턴스가 이미 생성된 이후에도 동기화 오버헤드가 발생하기 때문에 성능이 저하될 수 있습니다.결론싱글톤 패턴은 특정 클래스의 인스턴스를 하나만 생성하여 전역적으로 접근할 수 있도록 보장하는 유용한 디자인 패턴입니다. 그러나 멀티스레드 환경에서는 추가적인 동기화 처리가 필요합니다. 이러한 패턴을 잘 활용하면 자원 낭비를 줄이고, 애플리케이션의 일관성을 유지하는 데 도움이 됩니다."
  },
  
  {
    "title": "소켓 게임 서버 개발- 멀티스레드 활용",
    "url": "/posts/multiThread/",
    "categories": "Development, Operating Systems",
    "tags": "java, processes, threads, os",
    "date": "2024-07-25 20:33:00 +0900",
    





    
    "snippet": "소켓 게임 개발자바를 사용한 멀티유저 소켓 게임 서버 개발 프로젝트에서 스레드를 활용한 경험에 대한 내용입니다.프로젝트 개요프로젝트 설명이 프로젝트는 자바로 개발한 멀티플레이어 소켓 게임으로, 여러 클라이언트가 동시에 접속하고 상호작용할 수 있는 퀴즈 게임입니다. 주요 기능은 클라이언트 간의 실시간 소통과 퀴즈 진행입니다.기술 스택  자바 (Java)...",
    "content": "소켓 게임 개발자바를 사용한 멀티유저 소켓 게임 서버 개발 프로젝트에서 스레드를 활용한 경험에 대한 내용입니다.프로젝트 개요프로젝트 설명이 프로젝트는 자바로 개발한 멀티플레이어 소켓 게임으로, 여러 클라이언트가 동시에 접속하고 상호작용할 수 있는 퀴즈 게임입니다. 주요 기능은 클라이언트 간의 실시간 소통과 퀴즈 진행입니다.기술 스택  자바 (Java)  소켓 프로그래밍  멀티스레딩스레드 구현서버는 다수의 클라이언트와 동시에 상호작용할 수 있어야 합니다. 이를 위해 각 클라이언트의 연결을 별도의 스레드에서 처리하였습니다.서버 스레드 구조서버는 클라이언트의 연결을 수신하기 위해 AcceptServer 스레드를 사용하고, 각 클라이언트의 요청을 처리하기 위해 UserService 스레드를 생성합니다.// 새로운 참가자 accept() 하고 user thread를 새로 생성한다.class AcceptServer extends Thread {\t@SuppressWarnings(\"unchecked\")\tpublic void run() {\t\twhile (true) { \t\t\t// 사용자 접속을 계속해서 받기 위해 \t\t}    }}// 클라이언트 요청을 처리하는 스레드class UserService extends Thread {\t\tprivate Socket clientSocket;    public UserService(Socket clientSocket) {        this.clientSocket = clientSocket;    }    public void run() {        // 클라이언트와의 상호작용 처리    }}데이터 충돌 문제여러 플레이어가 동시에 여러 방에 참가하거나 게임을 진행할 때 데이터 충돌 문제가 발생했습니다. 하나의 서버 파일에서 모든 것을 관리하는 방식으로 인해 중간에 플레이어가 들어오면 값이 변경되어 다른 플레이어에게 영향을 주는 상황이 발생했습니다.문제 해결문제를 해결하기 위해 각 플레이어별로 스레드를 생성하여 동시에 여러 방에 참가할 수 있도록 했습니다. 또한, 각 방의 상태를 독립적으로 관리하기 위해 Room 객체와 RoomManager 클래스를 도입했습니다.Room 객체와 RoomManager 클래스각 방의 상태를 효율적으로 관리하기 위해 Room 객체와 RoomManager 클래스를 만들었습니다.class Room {    private String roomName;    private Vector&lt;UserService&gt; users;    public Room(String roomName) {        this.roomName = roomName;        this.users = new Vector&lt;&gt;();    }    public void addUser(UserService user) {        users.add(user);    }    public void removeUser(UserService user) {        users.remove(user);    }}class RoomManager {    private Map&lt;String, Room&gt; rooms;    public RoomManager() {        rooms = new HashMap&lt;&gt;();    }    public Room getRoom(String roomName) {        return rooms.get(roomName);    }    public void createRoom(String roomName) {        rooms.put(roomName, new Room(roomName));    }}"
  },
  
  {
    "title": "프로세스와 스레드 - 개념과 차이점",
    "url": "/posts/thread-process/",
    "categories": "Development, Operating Systems",
    "tags": "processes, threads, os",
    "date": "2024-07-23 20:33:00 +0900",
    





    
    "snippet": "프로세스와 스레드프로세스와 스레드는 우리가 사용하는 컴퓨터 시스템의 핵심 구성 요소입니다.프로세스 (Processes)프로세스는 실행 중인 프로그램의 독립적인 인스턴스입니다. 하나의 프로그램이 여러 번 실행되면, 각 실행마다 별도의 프로세스가 생성됩니다. 각 프로세스는 최소 1개의 스레드를 가지고 있습니다.특징  독립적인 메모리 공간  자원의 독립적인...",
    "content": "프로세스와 스레드프로세스와 스레드는 우리가 사용하는 컴퓨터 시스템의 핵심 구성 요소입니다.프로세스 (Processes)프로세스는 실행 중인 프로그램의 독립적인 인스턴스입니다. 하나의 프로그램이 여러 번 실행되면, 각 실행마다 별도의 프로세스가 생성됩니다. 각 프로세스는 최소 1개의 스레드를 가지고 있습니다.특징  독립적인 메모리 공간  자원의 독립적인 관리  프로세스 간의 통신이 필요작동 방식프로세스는 운영 체제에 의해 관리되며, 각각 독립적인 주소 공간을 가지고 실행됩니다. 운영 체제는 각 프로세스에 메모리와 자원을 할당하고, 이 자원은 프로세스가 종료될 때까지 유지됩니다.스레드 (Threads)스레드는 프로세스 내에서 실행되는 작은 실행 단위입니다. 스레드는 프로세스의 자원을 공유하여 실행되며, 다른 스레드의 실행 결과를 바로 확인할 수 있습니다.특징  메모리와 자원 공유  빠른 생성과 종료  동기화 문제 발생 가능작동 방식스레드는 같은 프로세스 내에서 여러 작업을 동시에 수행할 수 있습니다. 이로 인해, 더 효율적으로 작업을 수행할 수 있으며 특히 멀티코어 시스템에서 유리합니다.프로세스와 스레드의 차이점메모리 관리프로세스는 독립적인 메모리 공간을 가지며, 스레드는 이 메모리를 공유합니다. 이는 프로세스 간의 간섭을 막아 안정성을 높이지만, 메모리 사용량이 많아질 수 있습니다. 반면 스레드는 메모리를 공유함으로써 자원을 효율적으로 사용할 수 있지만, 동기화 문제로 인해 데이터 일관성을 유지하는 것이 중요합니다.자원 관리프로세스는 자원을 독립적으로 관리합니다. 이는 한 프로세스가 다른 프로세스의 자원에 접근할 수 없음을 의미하며, 각 프로세스가 독립적으로 실행되어 안정성이 높습니다. 반면 스레드는 자원을 공유하여 작업을 수행하므로 더 빠르고 효율적이지만, 동기화 문제로 인해 충돌이 발생할 수 있습니다."
  },
  
  {
    "title": "의존성 주입과 테스트(2) - Mockito",
    "url": "/posts/mockito/",
    "categories": "Development, Test",
    "tags": "java, tdd, mockito",
    "date": "2024-07-20 20:33:00 +0900",
    





    
    "snippet": "테스트 코드: 실제 데이터베이스 연결 없이 테스트하기이전 포스트에서는 생성자 주입 방식으로 의존성 주입을 변경했습니다. 이번에는 Mockito를 사용하여 테스트 코드를 작성해보았습니다.@Mock으로 변경실제 데이터베이스와 연결하여 테스트를 진행할 수도 있었지만, 데이터베이스에 많은 데이터가 쌓여 있다 보니 테스트 속도가 느려질 수 있을 것 같다는 생각...",
    "content": "테스트 코드: 실제 데이터베이스 연결 없이 테스트하기이전 포스트에서는 생성자 주입 방식으로 의존성 주입을 변경했습니다. 이번에는 Mockito를 사용하여 테스트 코드를 작성해보았습니다.@Mock으로 변경실제 데이터베이스와 연결하여 테스트를 진행할 수도 있었지만, 데이터베이스에 많은 데이터가 쌓여 있다 보니 테스트 속도가 느려질 수 있을 것 같다는 생각이 들었습니다.테스트 속도를 향상시키고, 서비스 의존성 방식을 변경하여 외부 의존성을 제거하고 특정 컴포넌트의 동작만을 테스트하고 싶었습니다. 또한, 예외 상황이나 특정 데이터 등을 쉽게 테스트하고 싶어서 Mock으로 변경하기로 결정했습니다.@Autowired vs @Mock테스트 코드에서 @Autowired와 @Mock을 사용하는 방법이 있습니다.@Autowired      특징: 실제 Spring 컨텍스트를 로드하여, 실제 빈(bean)들을 주입받아 테스트합니다.    장점:                  실제 환경과 유사한 테스트가 가능하여, 통합 테스트에 유리합니다.                    전체 애플리케이션의 흐름을 점검할 수 있습니다.              단점:                  Spring 컨텍스트 로딩 시간이 필요하기 때문에 테스트가 느릴 수 있습니다.                    특정 컴포넌트의 독립적인 테스트가 어려울 수 있습니다. 여러 컴포넌트들이 연계되어 작동하므로 문제의 원인을 파악하기 힘들 수 있습니다.            @Mock      특징: Mockito 등을 사용하여 모의 객체를 생성하고 주입합니다.    장점:                  모의 객체를 사용하므로 Spring 컨텍스트를 로드할 필요가 없기 때문에 빠른 테스트가 가능합니다.                    특정 컴포넌트를 독립적으로 테스트할 수 있습니다. 외부 의존성을 제거하고, 테스트하려는 컴포넌트에 집중할 수 있습니다.                    모의 객체의 동작을 원하는 대로 설정할 수 있어 다양한 시나리오를 쉽게 테스트할 수 있습니다.              단점:                  실제 환경과의 차이가 있을 수 있습니다. 모의 객체는 실제 객체와 완전히 동일하게 동작하지 않을 수 있습니다.                    통합 테스트를 수행하기에는 적절하지 않을 수 있습니다. 모의 객체는 실제 데이터베이스나 네트워크와 상호작용하지 않기 때문입니다.            문제점Mock으로 테스트를 진행하는 과정에서 데이터를 저장하는 save 메서드를 호출했음에도 불구하고, findAll 메서드를 통해 데이터를 조회할 때 항상 0개의 데이터만 반환되는 문제가 발생했습니다.@ExtendWith(MockitoExtension.class)public class NovelCrawlerServiceTest {    @Mock    private NovelRepository novelRepository;    @InjectMocks    private NovelCrawlerService novelCrawlerService;    @DisplayName(\"데이터베이스에 소설 저장 및 조회 테스트\")    @Test    void saveNovelsTest() {        ContentDTO content = new ContentDTO(\"Title\", \"coverImg\", \"summary\", \"genre\", false, \"테스트ID\");        List&lt;ContentDTO&gt; list = new ArrayList&lt;&gt;();        list.add(content);        novelCrawlerService.saveNovels(list, \"네이버시리즈\");        Novel result = novelCrawlerService.getDataByTitle(\"Title\");        // 적절한 Mockito 검증 로직 추가        assertEquals(\"Title\", result.getTitle());        assertEquals(\"coverImg\", result.getCoverImg());        assertEquals(\"summary\", result.getSummary());        assertEquals(\"genre\", result.getGenre());        assertEquals(1, result.getSites().size());        assertEquals(\"네이버시리즈\", result.getSites().get(0).getSite().getName());        assertEquals(\"테스트ID\", result.getSites().get(0).getProductId());        deleteNovelTestDataByTitle(\"Title\");    }위 코드에서 result가 null로 뜨는 문제가 발생하여, 데이터가 DB에 저장되지 않는 문제를 겪었습니다.문제 해결 : 최종 코드Mock 객체를 사용하면서 실제 데이터베이스와의 연동이 이루어지지 않기 때문에Mock 객체를 사용할 때는 해당 클래스의 동작을 명확히 설정해줘야 합니다.@ExtendWith(MockitoExtension.class)public class NovelCrawlerServiceTest {    @Mock    private NovelRepository novelRepository;    @InjectMocks    private NovelCrawlerService novelCrawlerService;    private ContentDTO content;    private Novel mockNovel;    @BeforeEach    void setUp() {        // 공통 데이터 설정        content = new ContentDTO(\"Title\", \"coverImg\", \"summary\", \"genre\", false, \"테스트ID\");        mockNovel = new Novel(content.getTitle(), content.getCoverImg(), content.getSummary(),                content.getGenre(), content.isAdultContent());    }    @DisplayName(\"소설 저장 테스트\")    @Test    public void saveNovelsTest() {        List&lt;ContentDTO&gt; list = new ArrayList&lt;&gt;();        list.add(content);        // Given: 초기 상태에서는 소설이 존재하지 않음        when(novelRepository.findByTitle(\"Title\")).thenReturn(null);        // When: 소설을 저장        novelCrawlerService.saveNovels(list, \"네이버시리즈\");        // Then: 소설이 저장되었는지 확인        verify(novelRepository, times(1)).save(any(Novel.class));    }    //테스트 코드..}      초기 상태 설정 : @BeforeEach 메서드를 추가하여 각 테스트 실행 전에 공통으로 사용할 데이터를 설정했습니다. 이를 통해 각 테스트가 독립적으로 동일한 초기 상태에서 시작될 수 있도록 했습니다.        Mock 설정 추가 : when(novelRepository.findByTitle(\"Title\")).thenReturn(null);을 통해 초기 상태에서 소설이 존재하지 않는다는 것을 명시했습니다. 이를 통해 saveNovels 메서드를 호출할 때 실제로 새로운 소설을 저장하도록 유도했습니다.        검증 로직 추가 : verify(novelRepository, times(1)).save(any(Novel.class));을 통해 novelRepository의 save 메서드가 정확히 한 번 호출되었는지 검증했습니다. 이를 통해 소설이 제대로 저장되었는지 확인할 수 있었습니다.  위와 같이 수정된 코드를 통해 Mock 객체를 활용한 테스트에서 발생했던 문제를 해결하고, 원하는 테스트 시나리오를 성공적으로 검증할 수 있었습니다.요약Mockito를 사용하여 데이터베이스와의 상호작용을 모의(mock)하기 때문에, 데이터베이스에 저장되는 것처럼 시뮬레이션할 뿐입니다. 이를 통해 특정 동작을 검증할 수 있습니다.Mockito를 사용한 테스트는 실제 데이터베이스와 연결되지 않고, 데이터베이스와의 상호작용을 모의 객체로 대체하여 수행합니다. verify 메서드를 사용하여 save 메서드가 호출되었는지 확인할 수 있지만, 실제로 데이터베이스에 데이터가 저장되지는 않습니다.Mock 객체를 활용한 테스트에서는 테스트 속도를 빠르게 유지하고, 특정 컴포넌트의 동작을 독립적으로 검증할 수 있습니다. 이는 다양한 시나리오를 쉽게 테스트하고, 외부 의존성에 영향을 받지 않는 안정적인 테스트 환경을 제공하는 데 유용합니다."
  },
  
  {
    "title": "의존성 주입과 테스트(1) - @Autowired",
    "url": "/posts/test-code/",
    "categories": "Development, Test",
    "tags": "java, spring",
    "date": "2024-07-19 14:33:00 +0900",
    





    
    "snippet": "기존 코드: @Autowired 사용처음에는 @Autowired를 사용하여 의존성을 주입했습니다. 아래는 초기 설정 코드입니다.@SpringBootTestpublic class NovelCrawlerServiceTest {    @Autowired    private NovelCrawlerService novelCrawlerService;    @Di...",
    "content": "기존 코드: @Autowired 사용처음에는 @Autowired를 사용하여 의존성을 주입했습니다. 아래는 초기 설정 코드입니다.@SpringBootTestpublic class NovelCrawlerServiceTest {    @Autowired    private NovelCrawlerService novelCrawlerService;    @DisplayName(\"데이터베이스에 소설 저장 및 조회 테스트\")    @Test    void saveNovelsTest() {}    @DisplayName(\"같은 작품에 대해서 다른 사이트일 때 사이트 정보만 추가되는지 확인하는 테스트\")    @Test    void saveNovels_existingNovelTest() {}}처음에는 필드 주입을 사용하여 서비스 코드를 작성했고, 테스트 코드도 당연히 @Autowired로 작성했습니다.문제점      가독성 : 어떤 의존성이 주입되는지 명확히 알기 어렵고, 특히 여러 의존성이 있다보니 더 혼란스러움        테스트 실행 속도 : 테스트 클래스마다 컨텍스트를 새로 로드하기 때문에 시간이 많이 소요        의존성 관리 : 필드 주입 방식은 테스트에서 의존성을 모킹하기 어려움  서비스 코드 : @Autowired에서 생성자 주입으로 전환Spring 애플리케이션에서 의존성 주입 방식을 @Autowired에서 생성자 주입으로 변경하게 되면서 테스트 코드도 수정하게 되었습니다.@Service@RequiredArgsConstructorpublic class NovelCrawlerService {    private final NovelRepository novelRepository;    private final SiteRepository siteRepository;    private final NovelSiteRepository novelSiteRepository;    private final NaverSeriesCrawler naverSeriesCrawler;    private final KakaoPageCrawler kakaoPageCrawler;    // 서비스 메소드들}고민되는 부분Mock vs 실제 DB서비스 코드를 생성자 주입 방식으로 변경한 후 테스트 코드 작성에 대한 고민이 있었습니다. NovelCrawlerService의 메서드들은 DB와 관련된 서비스이다 보니, 테스트 코드를 실제 DB와 연결해야 할지에 대한 고민이 있었습니다.다음 포스트에서는 Mock 객체를 활용한 테스트 코드를 작성해보겠습니다."
  },
  
  {
    "title": "MongoDB에서 MySQL로의 전환 - 관계형 데이터베이스에서 리스트 저장 문제",
    "url": "/posts/MySQL-MongoDB/",
    "categories": "Development, Test",
    "tags": "java, tdd",
    "date": "2024-07-16 14:33:00 +0900",
    





    
    "snippet": "MongoDB에서의 데이터 관리 경험MongoDB를 통해 데이터를 관리하면서 얻은 경험과 기술적인 고민을 다음과 같이 정리했습니다.데이터 모델링과 문서형 데이터베이스의 활용MongoDB는 문서형 데이터베이스로서 스키마 없는 구조를 제공하여 초기 데이터 모델링과 저장이 매우 유연했습니다. 예를 들어, 다음과 같은 방식으로 데이터를 저장할 수 있었습니다{...",
    "content": "MongoDB에서의 데이터 관리 경험MongoDB를 통해 데이터를 관리하면서 얻은 경험과 기술적인 고민을 다음과 같이 정리했습니다.데이터 모델링과 문서형 데이터베이스의 활용MongoDB는 문서형 데이터베이스로서 스키마 없는 구조를 제공하여 초기 데이터 모델링과 저장이 매우 유연했습니다. 예를 들어, 다음과 같은 방식으로 데이터를 저장할 수 있었습니다{  \"_id\": id,  \"title\": \"작품 제목\",  \"coverImg\": \"작품 이미지\",  \"summary\": \"작품 요약\",  \"genre\": \"장르\",  \"site\": [\"사이트1\", \"사이트2\", \"사이트3\"],  \"adultContent\": false}하나의 작품이 여러 사이트에서 연재될 수 있다는 점을 고려하여, 해당 작품의 사이트 정보를 리스트로 저장할 수 있도록 했습니다. MongoDB는 유연한 데이터 모델을 제공하여 리스트 형태의 데이터를 쉽게 다룰 수 있었습니다.초기 장점과 유연성MongoDB의 문서형 데이터베이스 특성 덕분에, 각 문서에 다양한 필드와 데이터 구조를 유연하게 저장할 수 있었습니다. 이 방식은 초기 데이터 모델링과 저장이 매우 간편하고 직관적이었으며, 프로젝트의 초기 단계에서 빠르게 발전할 수 있도록 도와주었습니다.고민Selenium을 사용하여 웹페이지에서 추출한 데이터를 MongoDB에 저장한 후, 다음과 같은 기술적인 고민을 하게 되었습니다.MySQL로의 전환 이유Selenium으로 웹페이지에서 추출한 데이터를 데이터베이스에 저장한 후 화면에 띄우기 위해, 처음에는 비관계형 데이터베이스인 MongoDB를 사용했습니다. MongoDB는 유연한 스키마와 문서 기반 저장 방식 덕분에 초기 개발 및 데이터 저장이 용이했습니다.하지만 프로젝트를 진행하면서 좀 더 정교한 데이터 관리 기능이 필요하다는 것을 느꼈습니다. 유저의 좋아요 기능을 추가하려면 유저와 작품 데이터 간의 관계를 명확히 표시할 수 있어야 했습니다.  MongoDB는 유연한 데이터 모델을 제공했지만, 복잡한 관계를 관리하는 데 한계가 있었습니다. 이러한 관계형 데이터를 효과적으로 관리하기 위해 관계형 데이터베이스로 전환을 고려하게 되었습니다.문제점관계형 데이터베이스로 전환하는 과정에서, 연재되는 사이트를 리스트로 관리해왔던 것이 MySQL에서는 직접적으로 리스트 저장이 불가능하다는 문제를 발견하게 되었습니다. MongoDB에서는 리스트 데이터를 자연스럽게 저장하고 관리할 수 있었지만, MySQL에서는 이러한 데이터를 효과적으로 저장하고 처리하기 위해 추가적인 설계가 필요했습니다.해결 방안데이터 모델 재구성과 novel_site 테이블 설계MySQL에서는 리스트 형태의 데이터를 직접 저장하는 것이 어려웠기 때문에, 각 작품과 사이트의 관계를 명확히 나타낼 수 있는 novel_site 테이블을 생성하여 데이터베이스를 설계하였습니다. 사이트 ID와 작품 ID를 저장하는 방식으로 이를 통해 각각의 작품이 여러 사이트에서 연재되는 정보를 효과적으로 관리할 수 있게 되었습니다.-- 작품 테이블CREATE TABLE novel (    _id INT AUTO_INCREMENT PRIMARY KEY,    title VARCHAR(255) NOT NULL,    cover_img VARCHAR(255),    summary TEXT,    genre VARCHAR(50),    adult_content BOOLEAN);-- 사이트 테이블CREATE TABLE site (    _id INT AUTO_INCREMENT PRIMARY KEY,    name VARCHAR(255) NOT NULL,    url VARCHAR(255));-- 작품-사이트 관계 테이블CREATE TABLE novle_site (    id INT AUTO_INCREMENT PRIMARY KEY,    product_id INT,    novel_id INT,    site_id INT,    FOREIGN KEY (novle_id) REFERENCES novle(_id),    FOREIGN KEY (site_id) REFERENCES site(_id));"
  },
  
  {
    "title": "JUnit을 이용한 단위 테스트",
    "url": "/posts/JUnit/",
    "categories": "Development, Test",
    "tags": "java, tdd",
    "date": "2024-07-15 14:33:00 +0900",
    





    
    "snippet": "테스트코드테스트 코드는 소프트웨어가 제대로 동작하는지 확인하기 위해 작성하는 코드입니다. 이 코드는 예상한 결과가 맞게 나오는지를 자동으로 검증해줍니다.테스트 코드를 작성해야하는 이유      버그 방지: 코드를 변경할 때 예상치 못한 버그를 사전에 발견하여 수정할 수 있습니다.        리팩토링 지원: 코드를 개선할 때 기존 기능이 제대로 동작하...",
    "content": "테스트코드테스트 코드는 소프트웨어가 제대로 동작하는지 확인하기 위해 작성하는 코드입니다. 이 코드는 예상한 결과가 맞게 나오는지를 자동으로 검증해줍니다.테스트 코드를 작성해야하는 이유      버그 방지: 코드를 변경할 때 예상치 못한 버그를 사전에 발견하여 수정할 수 있습니다.        리팩토링 지원: 코드를 개선할 때 기존 기능이 제대로 동작하는지 확인하고 안전하게 변경할 수 있습니다.        문서화: 코드의 동작을 명확하게 문서화하여 다른 개발자들이 이해하기 쉽게 합니다.        자동화된 검증: 반복적인 테스트 과정을 자동화하여 개발 효율성을 높입니다.        코드 품질 향상: 코드의 신뢰성과 유지보수성을 개선할 수 있습니다.  테스트 주도 개발(TDD)테스트 주도 개발(Test Driven Development, TDD)은 코드를 작성하기 전에 테스트를 먼저 작성하는 개발 방법론입니다.일반 개발 방식과 TDD 개발 방식의 차이  일반 개발 방식일반적인 개발 방식은 보통 요구사항 분석 -&gt; 설계 -&gt; 개발 -&gt; 테스트 -&gt; 배포의 순서로 진행됩니다. 이 방식은 초기에 요구사항이 명확하지 않거나 중간에 변경될 수 있어, 완벽한 설계를 하기 어렵고 잠재적인 위험이 있습니다. 중간에 요구사항이 변경되면 코드를 수정하고 추가하면서 불필요한 코드가 쌓일 수 있으며, 이는 나중에 코드를 유지보수하고 재사용하기 어렵게 만들 수 있습니다.  TDD 개발 방식TDD와 일반적인 개발 방식의 가장 큰 차이점은 테스트 코드의 작성 단계입니다.TDD는 설계 단계에서 목적과 무엇을 테스트해야 할지 미리 테스트케이스를 작성하는 단계를 거칩니다.TDD의 과정      테스트 작성: 기능이나 요구사항을 테스트하는 테스트 케이스를 작성합니다. 이 단계에서는 해당 기능이 실패할 것을 예상합니다.    코드 작성: 최소한의 코드만 작성하여 1번에서 작성하였던 실패하는 테스트를 통과할 수 있도록 만듭니다. 이 과정에서 기능을 추가하거나 수정합니다.  리팩토링: 작성한 코드를 개선하고 중복을 제거합니다. 이 과정에서 코드의 구조를 더 명확하고 유지보수하기 쉽도록 개선합니다.TDD의 핵심은 코드를 작성하기 전에 테스트를 먼저 작성하여 요구사항이나 기능의 목적을 명확하게 이해하고 검증하는 것입니다. 이 방식은 초기 설계 단계부터 테스트가 포함되어 있어 변경 사항에 대응하기 용이하며, 코드의 품질과 유지보수성을 높이는 데 도움을 줍니다.JUnitJUnit은 자바 애플리케이션의 테스트를 위한 표준 프레임워크입니다.JUnit의 기본 어노테이션      @Test : 테스트 메서드 정의        @BeforeEach : 테스트 메소드들이 실행되기 전에 매번 실행되는 메소드로 지정        @BeforeAll : 전체 테스트가 실행되기 전 딱 한번만 실행        @AfterEach : 테스트 메소드들이 실행되고 난 후 매번 실행되는 메소드로 지정        @AfterAll :전체 테스트가 끝난 후 한번 실행  AssertJAssertJ는 JUnit과 함께 사용되어 객체나 결과를 검증하는 데 유용한 메서드를 제공합니다      assertArrayEquals(a,b) : 배열 a,b 일치함 확인        assertEquals(a,b) : 객체 a,b 같은 값  가지는지 확인        assertEquals(a,b,c) : 객체 a,b 값이 일치함을 확인(c는 오차범위)        assertSame(a,b) : 객체 a,b가 같은 객체임을 확인        assertTrue(a) : 조건 a가 참인지 확인        assertNotNull(a) : 객체 A가 null이 아님 확인  예시: 간단한 단위 테스트다음은 간단한 계산기(Calculator) 클래스와 이를 테스트하기 위한 테스트 코드의 예시입니다. 이 예시는 JUnit을 사용하여 기본적인 덧셈, 뺄셈, 나눗셈 기능과 예외 상황을 테스트합니다.class Calculator {    public int add(int a, int b) {        return a + b;    }    public int subtract(int a, int b) {        return a - b;    }    public int divide(int a, int b) {        return a / b;    }}class CalculatorTest {    // 덧셈 테스트    @Test    void additionTest() {        Calculator calculator = new Calculator();        int result = calculator.add(2, 3);        assertEquals(5, result, \"2 + 3은 5여야 합니다.\");    }    // 뺄셈 테스트    @Test    void subtractionTest() {        Calculator calculator = new Calculator();        int result = calculator.subtract(5, 3);        assertEquals(2, result, \"5 - 3은 2여야 합니다.\");    }    // 나눗셈 테스트    @Test    void divisionTest() {        Calculator calculator = new Calculator();        int result = calculator.divide(6, 3);        assertEquals(2, result, \"6 / 3은 2여야 합니다.\");    }    // 0으로 나누기 테스트    @Test    void divisionByZeroTest() {        Calculator calculator = new Calculator();        // 0으로 나눌 때 ArithmeticException이 발생하는지 테스트        assertThrows(ArithmeticException.class, () -&gt; calculator.divide(6, 0), \"0으로 나누면 ArithmeticException이 발생해야 합니다.\");    }}"
  },
  
  {
    "title": "DB 트랜잭션",
    "url": "/posts/Transaction/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-12 14:33:00 +0900",
    





    
    "snippet": "트랜잭션이란?트랜잭션(Transaction)은 데이터베이스에서 하나의 작업 단위를 말합니다. 트랜잭션은 여러 작업을 하나의 논리적인 작업을 묶어서 처리하며, ACID 특징을 가지고 있습니다.ACID 속성      원자성(Atomicity): 트랜잭션의 모든 작업이 완료되거나, 전혀 수행되지 않은 상태를 보장        일관성(Consistency):...",
    "content": "트랜잭션이란?트랜잭션(Transaction)은 데이터베이스에서 하나의 작업 단위를 말합니다. 트랜잭션은 여러 작업을 하나의 논리적인 작업을 묶어서 처리하며, ACID 특징을 가지고 있습니다.ACID 속성      원자성(Atomicity): 트랜잭션의 모든 작업이 완료되거나, 전혀 수행되지 않은 상태를 보장        일관성(Consistency): 트랜잭션이 완료되면 데이터베이스 항상 일관된 상태 유지        격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로의 작업에 영향을 미치지 않도록 격리        지속성(Durability): 트랜잭션이 완료된 후에는 시스템 오류가 발생하더라도 그 결과 지속  트랜잭션 관리트랜잭션 관리는 데이터 일관성을 유지하고 데이터베이스 작업 중 오류가 발생했을 때 안전하게 복구할 수 있도록 도와주는 중요한 기능입니다.Spring 프레임워크에서는 트랜잭션 관리를 위해 @Transactional 어노테이션을 제공합니다.@Transactional 어노테이션 사용법@Transactional 어노테이션은 클래스나 메서드에 적용할 수 있습니다.@Servicepublic class MyService {    private final MyRepository myRepository;    public MyService(MyRepository myRepository) {        this.myRepository = myRepository;    }    @Transactional    public void performTransaction() {        // 트랜잭션 내에서 실행될 코드        myRepository.save(new Entity());        myRepository.update(new Entity());        ...    }}커밋과 롤백      커밋(commit)                  트랜잭션이 성공적으로 완료되면 커밋을 통해 모든 변경 사항을 확정합니다.&lt;/span&gt;                    커밋이 수행되면 트랜잭션 내에서 이루어진 모든 데이터 변경이 데이터베이스에 영구적으로 반영됩니다.                    커밋이 완료된 후에는 해당 세션이 종료되며, 다른 트랜잭션이나 커넥션에서도 이 변경 사항을 볼 수 있게 됩니다.                  롤백(rollback)                  트랜잭션 내에서 오류가 발생하거나, 중간에 작업을 취소할 필요가 있는 경우 롤백을 통해 모든 변경 사항을 취소합니다.                    롤백이 수행되면 트랜잭션 시작 이전 상태로 데이터베이스가 복구됩니다.                    롤백 후에는 해당 세션이 종료되며, 변경 사항이 데이터베이스에 반영되지 않기 때문에 다른 트랜잭션이나 커넥션에서는 롤백된 내용을 볼 수 없습니다.            트랜잭션 진행 중 데이터 접근하나의 트랜잭션이 진행 중일 때, 다른 트랜잭션이나 커넥션에서 해당 데이터에 접근하면 현재 트랜잭션 격리 수준에 따라 데이터 접근 방식이 달라집니다.트랜잭션 격리 수준트랜잭션 격리 수준은 트랜잭션이 다른 트랜잭션의 작업을 얼마나 격리할지를 결정합니다. 이를 통해 하나의 트랜잭션이 진행 중일 때 다른 트랜잭션이 어떻게 데이터를 볼 수 있는지 제어할 수 있습니다.Spring 격리 수준 지정isolation 속성을 사용하여 트랜잭션의 격리 수준을 설정할 수 있습니다.  DEFAULT: 기본 데이터베이스 격리 수준 사용  READ_UNCOMMITTED: 가장 낮은 격리 수준, “더티 리드” 허용  READ_COMMITTED: 커밋된 데이터만 읽음  REPEATABLE_READ: 동일한 쿼리 반복 시 항상 동일한 결과 반환  SERIALIZABLE: 가장 높은 격리 수준, 트랜잭션이 순차적으로 실행되는 것처럼 보장    @Transactional(isolation = Isolation.READ_COMMITTED)      주의사항      트랜잭션 크기: 너무 큰 트랜잭션은 데이터베이스 Lock 문제가 발생할 수 있기 때문에 가능한 작게 유지하는 것이 좋습니다.        예외처리: 트랜잭션 내에서 예외가 발생하면 Spring은 기본적으로 해당 트랜잭션을 롤백합니다. 그러나 모든 예외가 자동으로 롤백되는 것은 아니며, 예외를 적절히 처리하지 않으면 예상치 못한 동작이 발생할 수 있습니다.        성능: 데이터베이서의 성능에 영향을 미칠 수 있어, 필요한 최소한의 범위에서 사용해야 합니다.  "
  },
  
  {
    "title": "어노테이션(Annotation), @",
    "url": "/posts/Annotation/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-10 14:33:00 +0900",
    





    
    "snippet": "어노테이션Spring 프레임워크는 다양한 어노테이션을 통해 개발자가 코드를 간결하고 명확하게 작성할 수 있도록 도와줍니다. 여기서 어노테이션은 무엇일까요?어노테이션(Annotation)은 코드에 추가적인 정보를 제공하는 특별한 표식입니다. 주석처럼 보이지만, 차이점은 실행 중에도 이 정보를 사용할 수 있다는 점입니다. 주석은 단순히 코드에 대한 설명을...",
    "content": "어노테이션Spring 프레임워크는 다양한 어노테이션을 통해 개발자가 코드를 간결하고 명확하게 작성할 수 있도록 도와줍니다. 여기서 어노테이션은 무엇일까요?어노테이션(Annotation)은 코드에 추가적인 정보를 제공하는 특별한 표식입니다. 주석처럼 보이지만, 차이점은 실행 중에도 이 정보를 사용할 수 있다는 점입니다. 주석은 단순히 코드에 대한 설명을 추가하는 것이지만, 어노테이션은 프로그램이 실행될 때도 읽히고 사용될 수 있습니다.어노테이션의 역할Spring 프레임워크에서는 어노테이션을 사용해 다음과 같은 작업을 할 수 있습니다:      Bean 정의: Spring이 관리할 객체(Bean)를 정의할 때 사용합니다.        의존성 주입: 객체들 간의 의존 관계를 설정할 때 사용합니다.        요청 매핑: 웹 요청을 특정 메서드와 연결할 때 사용합니다.  쉽게 말해, 어노테이션은 Spring에게 “이 객체는 Bean으로 관리해줘”, “이 메서드는 웹 요청을 처리해줘” 등의 지시를 내리는 도구입니다.주요 어노테이션@Component, @Service, @Repository이 어노테이션들은 Spring의 컴포넌트 스캔을 통해 자동으로 Bean으로 등록됩니다.      @Component: 일반적인 Spring 관리 객체에 사용        @Service: 서비스 레이어에 사용, 비즈니스 로직을 포함        @Repository: 데이터 접근 객체(DAO)에 사용, 예외 처리를 Spring의 데이터 접근 예외로 변환  @Componentpublic class MyComponent {    ...}@Servicepublic class MyService {    ...}@Repositorypublic class MyRepository {    ...}@Autowired의존성 주입을 위해 사용됩니다. 생성자, 필드, 메서드에 적용할 수 있습니다.@Servicepublic class MyService {    @Autowired    private MyRepository myRepository;    ...}@Configuration, @BeanSpring 설정 클래스를 정의하고 Bean을 생성하는 방법을 제공합니다.      @Configuration: 하나 이상의 @Bean 메서드를 포함하는 클래스에 사용        @Bean: Spring 컨테이너가 관리하는 Bean을 생성하는 메서드에 사용  @Configurationpublic class AppConfig {    @Bean    public MyService myService() {        return new MyService();    }}@Controller, @RestControllerSpring MVC에서 컨트롤러 역할을 하는 클래스에 사용됩니다.      @Controller: 뷰를 반환하는 컨트롤러에 사용        @RestController: RESTful 웹 서비스의 컨트롤러에 사용, JSON/XML 형태로 객체 반환  @Controllerpublic class MyController {    @GetMapping(\"/hello\")    public String hello() {        return \"hello\";    }}@RestControllerpublic class MyRestController {    @GetMapping(\"/api/hello\")    public String apiHello() {        return \"hello\";    }}@RequestMapping, @GetMapping, @PostMappingHTTP 요청을 처리하기 위한 매핑 어노테이션입니다.      @RequestMapping: 모든 HTTP 메서드를 처리        @GetMapping: HTTP GET 요청을 처리        @PostMapping: HTTP POST 요청을 처리  @RestController@RequestMapping(\"/api\")public class ApiController {    @GetMapping(\"/items\")    public List&lt;Item&gt; getItems() {        return itemService.getAllItems();    }    @PostMapping(\"/items\")    public Item createItem(@RequestBody Item item) {        return itemService.saveItem(item);    }}@Transactional트랜잭션 관리를 위한 어노테이션입니다. 메서드나 클래스에 적용하여 해당 범위 내의 작업을 트랜잭션으로 묶어줍니다.@Servicepublic class MyService {    @Transactional    public void performTransaction() {        // 트랜잭션 내에서 실행될 코드    }}@Valid, @NotNull, @Size데이터 유효성 검사를 위한 어노테이션입니다.      @Valid: 객체의 유효성을 검사        @NotNull: 필드가 null이 아니어야 함을 명시        @Size: 문자열, 배열 등의 크기를 제한  public class User {    @NotNull    private String username;    @Size(min = 6, max = 20)    private String password;    ...}@RestController@RequestMapping(\"/users\")public class UserController {    @PostMapping    public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody User user) {           ...        return ResponseEntity.ok(\"유저 생성 성공\");    }}"
  },
  
  {
    "title": "의존성 주입(DI)의 3가지 유형",
    "url": "/posts/DI-Type/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-09 14:33:00 +0900",
    





    
    "snippet": "DI의 주요 유형  생성자 주입(Constructor Injection) : 의존성을 생성자를 통해 주입받는 방식          일반 생성자를 이용한 주입      public class UserService {    private final UserRepository userRepository;    public UserService(UserRep...",
    "content": "DI의 주요 유형  생성자 주입(Constructor Injection) : 의존성을 생성자를 통해 주입받는 방식          일반 생성자를 이용한 주입      public class UserService {    private final UserRepository userRepository;    public UserService(UserRepository userRepository) {        this.userRepository = userRepository;    }    ...}    2. Lombok의 @AllArgsConstructor 사용@AllArgsConstructorpublic class UserService {    private final UserRepository userRepository;    ...}  세터 주입(Setter Injection) : 의존성을 세터 메서드를 통해 주입받는 방식public class UserService {    private UserRepository userRepository;    // 세터를 통한 주입    public void setUserRepository(UserRepository userRepository) {        this.userRepository = userRepository;    }}  필드 주입(Field Injection) : 의존성을 필드에 직접 주입하는 방식public class UserService {    @Autowired    private UserRepository userRepository;}결론테스트 환경      생성자 주입(Constructor Injection)    장점          테스트 용이성: 객체를 생성할 때 모든 필수 의존성을 명시적으로 전달받기 때문에, 테스트 시 의존성을 쉽게 모의 객체(Mock)로 교체할 수 있습니다.         public class UserServiceTest {  @Test  public void testUserService() {      // Mock 객체 생성      UserRepository mockRepository = Mockito.mock(UserRepository.class);                  // 생성자 주입을 통해 의존성 주입      UserService userService = new UserService(mockRepository);      ...  } }                    불변성: 의존성이 생성자를 통해 한 번 설정되면 변경되지 않기 때문에 객체의 상태를 안정적으로 유지할 수 있습니다.        단점          코드 길이: 필드가 많은 클래스의 경우 생성자 파라미터가 길어질 수 있어 코드가 복잡해질 수 있습니다.            세터 주입(Setter Injection)    장점          유연성: 런타임 시점에 의존성을 동적으로 변경할 수 있어 특정 테스트 케이스에 필요한 의존성만 주입할 수 있습니다.         public class UserServiceTest {  @Test  public void testUserService() {      // Mock 객체 생성      UserRepository mockRepository = Mockito.mock(UserRepository.class);                  // Setter 주입을 통해 의존성 주입      UserService userService = new UserService();      userService.setUserRepository(mockRepository);      ...  } }                    선택적 의존성: 필요에 따라 의존성이 없는 상태로 객체를 생성할 수 있어 테스트가 용이합니다.        단점                  의존성 누락: 객체 생성 후에 의존성을 설정하지 않을 경우 NullPointerException과 같은 예외가 발생할 수 있습니다.                    객체의 상태 변경: 의존성이 외부에서 변경될 수 있어 객체의 상태를 예측하기 어려울 수 있습니다.                  필드 주입(Field Injection)    장점          간결한 코드: 필드 주입은 코드가 간결하고 직관적입니다. 별도의 생성자나 세터 메서드를 작성할 필요가 없어 테스트 코드 작성이 편리합니다.         public class UserServiceTest {  @Mock  private UserRepository mockRepository;          @InjectMocks  private UserService userService;          @Before  public void setUp() {      MockitoAnnotations.initMocks(this);  }          @Test  public void testUserService() {      ...  } }                      단점          테스트 어려움: 필드 주입을 사용할 경우, 테스트에서 의존성을 목 객체로 교체하기 어려울 수 있습니다. 이로 인해 테스트가 실제 데이터베이스나 외부 서비스에 의존해야 할 때 문제가 발생할 수 있습니다.      어떤 DI 유형을 선택해야 할까?      생성자 주입: 필수적인 의존성이 있는 경우나 불변성을 유지해야 할 때 좋은 선택입니다.        세터 주입: 선택적인 의존성이 필요한 경우나, 기본 생성자를 사용할 때 유용합니다.        필드 주입: 간단한 프로토타입 코드나 테스트용 코드에서 사용할 수 있지만, 일반적인 애플리케이션 코드에서는 지양하는 것이 좋습니다.  "
  },
  
  {
    "title": "의존성 주입(DI)의 필요성",
    "url": "/posts/DI/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-08 14:33:00 +0900",
    





    
    "snippet": "의존성 주입(Dependency Injection, DI)의존성 주입은 소프트웨어 설계 패턴 중 하나로, 객체 간의 의존성을 외부에서 주입하는 방법을 의미합니다. DI는 객체 지향 프로그래밍에서 객체 간의 결합도를 낮추고, 코드의 재사용성과 테스트 용이성을 높이기 위해 사용되고 있습니다.DI의 필요성먼저 의존성과 결합도 라는 개념을 이해해야 합니다.의...",
    "content": "의존성 주입(Dependency Injection, DI)의존성 주입은 소프트웨어 설계 패턴 중 하나로, 객체 간의 의존성을 외부에서 주입하는 방법을 의미합니다. DI는 객체 지향 프로그래밍에서 객체 간의 결합도를 낮추고, 코드의 재사용성과 테스트 용이성을 높이기 위해 사용되고 있습니다.DI의 필요성먼저 의존성과 결합도 라는 개념을 이해해야 합니다.의존성 주입은 소프트웨어 설계 패턴 중 하나로, 객체 간의 의존성을 외부에서 주입하는 방법을 의미합니다. DI는 객체 지향 프로그래밍에서 객체 간의 결합도를 낮추고, 코드의 재사용성과 테스트 용이성을 높이기 위해 사용되고 있습니다.의존성을 외부에서 주입하지 않고 직접 객체를 생성하면, 코드의 결합도가 높아지게 됩니다. 예를 들어, 아래의 코드를 살펴보겠습니다.public class UserService {    private UserRepository userRepository;    public UserService() {        this.userRepository = new UserRepository(); // 직접 객체 생성    }    public void performService() {        // 서비스 로직    }}위 코드에서는 UserService 클래스가 UserRepository 객체를 직접 생성하고 있습니다. 이는 UserService가 UserRepository에 강하게 결합되어 있음을 의미합니다. 만약 UserRepository의 구현을 변경해야 한다면, UserService도 함께 변경해야 할 가능성이 큽니다.예를 들어, UserRepository를 JdbcUserRepository로 변경한다고 가정해보겠습니다.public class UserService {    private JdbcUserRepository userRepository;    public UserService() {        this.userRepository = new JdbcUserRepository(); // 변경된 객체 생성    }    public void performService() {        // 서비스 로직    }}이 경우, UserRepository를 사용하는 모든 부분을 찾아서 JdbcUserRepository로 변경해야 합니다. 즉, 직접 객체를 생성하면 결합도가 높아지며, 변경 시 많은 부분의 수정이 필요합니다.DI를 사용한 설계의존성 주입을 사용하면 결합도를 낮출 수 있습니다. 아래 코드를 살펴보겠습니다.public class UserService {    private UserRepository userRepository;    public UserService(UserRepository userRepository) {        this.userRepository = userRepository; // 외부에서 주입    }    public void performService() {        // 서비스 로직    }}위 코드에서는 UserRepository를 생성자 매개변수로 받아서 주입하고 있습니다. 이를 통해 UserService는 UserRepository의 구체적인 구현체에 의존하지 않게 됩니다. 이제 UserRepository의 구현체가 변경되더라도 UserService의 코드를 수정할 필요가 없습니다. 예를 들어, JdbcUserRepository로 변경하고 싶다면, 서비스 클래스를 호출하는 부분만 수정하면 됩니다.UserRepository userRepository = new JdbcUserRepository();UserService userService = new UserService(userRepository);이처럼 의존성 주입을 사용하면 객체 간의 결합도를 낮출 수 있으며, 코드의 변경에 유연하게 대응할 수 있습니다. 또한, 테스트 시에도 목 객체(Mock Object)를 사용하여 유닛 테스트를 보다 용이하게 할 수 있습니다.직접 객체 생성과 DI 사용의 차이  직접 객체 생성 방식     private JdbcUserRepository userRepository;        특정 구현체(JdbcUserRepository)를 직접 사용하고, 클래스 필드도 해당 구현체 타입으로 선언합니다.    의존성 주입 방식    private UserRepository userRepository;        인터페이스(UserRepository) 타입으로 필드를 선언하고, 생성자를 통해 외부에서 구현체를 주입받습니다.  "
  },
  
  {
    "title": "관계형 / 비관계형 데이터베이스",
    "url": "/posts/RDBMS-NoSQL/",
    "categories": "Development, Database",
    "tags": "spring, java, database",
    "date": "2024-07-06 14:33:00 +0900",
    





    
    "snippet": "데이터베이스데이터베이스는 데이터를 효율적으로 저장하고 관리하는 시스템입니다. 데이터베이스는 크게 관계형 데이터베이스(Relational Database, RDBMS)와 비관계형 데이터베이스(Non-Relational Database, NoSQL)로 나눌 수 있습니다.관계형 데이터베이스 (RDBMS)관계형 데이터베이스는 데이터를 테이블 형태로 저장합니다...",
    "content": "데이터베이스데이터베이스는 데이터를 효율적으로 저장하고 관리하는 시스템입니다. 데이터베이스는 크게 관계형 데이터베이스(Relational Database, RDBMS)와 비관계형 데이터베이스(Non-Relational Database, NoSQL)로 나눌 수 있습니다.관계형 데이터베이스 (RDBMS)관계형 데이터베이스는 데이터를 테이블 형태로 저장합니다. 테이블은 행과 열로 구성되며, 각 행은 개별 레코드를, 각 열은 속성을 나타냅니다. RDBMS는 데이터를 SQL을 통해 관리합니다특징  장점      데이터 무결성과 일관성 보장: 데이터의 정확성과 일관성을 유지합니다.        복잡한 쿼리 가능: SQL을 사용하여 복잡한 데이터 조회 및 조작이 가능합니다.        데이터 관계 관리: 데이터 간의 명확한 관계를 정의하고 관리할 수 있습니다.    단점      스키마 변경의 어려움: 데이터 구조 변경이 어렵고 번거롭습니다.        확장성의 한계: 대규모 데이터 처리에 한계가 있을 수 있습니다.        비정형 데이터 처리의 어려움: 정형화되지 않은 데이터를 처리하기 어렵습니다.  주요 RDBMS 종류  MySQL  PostgreSQL  Oracle Database  Microsoft SQL Server비관계형 데이터베이스 (NoSQL)비관계형 데이터베이스는 다양한 데이터 모델을 지원하며, 유연한 스키마를 제공합니다. 이는 특히 대규모 데이터 처리와 높은 확장성이 필요한 환경에서 유리합니다.특징  장점      스키마의 유연성: 데이터 구조가 고정되어 있지 않아 다양한 데이터 형식을 저장할 수 있습니다.        높은 확장성: 수평적 확장이 용이하여 대규모 데이터 처리가 가능합니다.        빠른 성능: 특정 사용 사례에 최적화된 데이터 접근 및 조회 속도를 제공합니다.    단점      일관성 보장 어려움: ACID 특성을 완전히 보장하지 않을 수 있어 데이터 일관성에 문제가 발생할 수 있습니다.        제한된 복잡한 쿼리: 관계형 데이터베이스만큼 복잡한 쿼리를 지원하지 않을 수 있습니다.        표준화 부족: 다양한 NoSQL 데이터베이스가 존재하며, 각기 다른 API와 쿼리 언어를 사용합니다.  유형  키-값 데이터베이스 단순한 키와 값 쌍으로 데이터를 저장됩니다.    \"Student:1\" : {\"Name\": \"Kim\", \"BirthDate\": \"2000-01-15\"}  문서 지향 데이터베이스각 도큐먼트는 JSON, BSON 또는 XML 형식으로 저장됩니다.{  \"StudentID\": 1,  \"Name\": \"Kim\",  \"BirthDate\": \"2000-01-15\",  \"Classes\": [    {\"ClassID\": 101, \"ClassName\": \"Math\", \"TeacherName\": \"Mr. Thompson\"},    {\"ClassID\": 102, \"ClassName\": \"Science\", \"TeacherName\": \"Mrs. Lee\"}  ]}  컬럼 지향 데이터베이스행과 열로 구성된 테이블 형태를 사용합니다.    CREATE TABLE Students (    StudentID uuid PRIMARY KEY,    FirstName text,    LastName text,    BirthDate date    );    CREATE TABLE StudentClasses (    StudentID uuid,    ClassID uuid,    ClassName text,    PRIMARY KEY (StudentID, ClassID)    );  그래프 데이터베이스노드와 엣지로 구성된 그래프 형태로 데이터를 저장합니다.    CREATE (s:Student {StudentID: 1, FirstName: \"John\", LastName: \"Doe\", BirthDate: \"2000-01-15\"})    CREATE (c1:Class {ClassID: 101, ClassName: \"Math\", TeacherName: \"Mr. Thompson\"})    CREATE (c2:Class {ClassID: 102, ClassName: \"Science\", TeacherName: \"Mrs. Lee\"})    CREATE (s)-[:ENROLLED_IN]-&gt;(c1)    CREATE (s)-[:ENROLLED_IN]-&gt;(c2)주요 NoSQL DB 종류  MongoDB  Cassandra  Redis  Neo4j요약            특징      관계형 데이터베이스 (RDBMS)      비관계형 데이터베이스 (NoSQL)                  데이터 모델      테이블 기반 (행과 열)      다양한 모델 (문서, 키-값, 컬럼 패밀리, 그래프 등)              스키마      고정된 스키마      유연한 스키마 또는 스키마 없음              언어      SQL      데이터베이스에 따라 다양한 쿼리 언어              ACID 특성      지원 (Atomicity, Consistency, Isolation, Durability)      일부 데이터베이스에서만 지원              확장성      수직적 확장 (서버 성능 향상)      수평적 확장 (노드 추가)              일관성      강한 일관성      최종 일관성 또는 이벤트 일관성 (데이터베이스에 따라 다름)              복잡한 쿼리      지원 (조인, 서브쿼리 등)      일부 데이터베이스에서 제한적으로 지원              적용 사례      트랜잭션 처리, 복잡한 쿼리 및 보고서 생성      대규모 데이터 처리, 비정형 데이터, 분산 시스템              유형 예시      MySQL, PostgreSQL, Oracle, Microsoft SQL Server      MongoDB, Cassandra, Redis, Neo4j              데이터 무결성      높은 수준의 데이터 무결성 보장      데이터 무결성 보장이 약함 (유연성 강조)              관계 정의      테이블 간의 명확한 관계 (외래 키)      명시적인 관계 정의가 없음 (애플리케이션 수준에서 관리)              운영 및 유지보수      상대적으로 복잡한 운영 및 유지보수      상대적으로 간단한 운영 및 유지보수      "
  },
  
  {
    "title": "데이터베이스 연결 방식 JPA vs Mybatis",
    "url": "/posts/database-connection/",
    "categories": "Development, Database",
    "tags": "spring, java, database",
    "date": "2024-07-05 14:33:00 +0900",
    





    
    "snippet": "JPAJPA는 자바 애플리케이션에서 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리하는 ORM(Object-Relational Mapping) 프레임워크입니다.특징      객체-관계 매핑JPA는 자바 객체와 데이터베이스 테이블 간의 매핑을 정의할 수 있게 해줍니다.        데이터베이스 독립성JPA를 사용하면 특정 데이터베이스에 종속되지 않...",
    "content": "JPAJPA는 자바 애플리케이션에서 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리하는 ORM(Object-Relational Mapping) 프레임워크입니다.특징      객체-관계 매핑JPA는 자바 객체와 데이터베이스 테이블 간의 매핑을 정의할 수 있게 해줍니다.        데이터베이스 독립성JPA를 사용하면 특정 데이터베이스에 종속되지 않고 다양한 데이터베이스를 쉽게 교체할 수 있습니다.        생산성 JPA는 데이터베이스 연동과 관련된 많은 반복적인 코드를 줄여주어 개발 생산성을 높여줍니다.  연동 과정1. Entity 클래스 설계 및 작성먼저, 데이터베이스 테이블과 매핑될 Entity 클래스를 설계하고 작성합니다. 각 필드는 데이터베이스의 컬럼에 매핑됩니다.import javax.persistence.Entity;import javax.persistence.Id;@Entitypublic class User {    @Id    private Long id;    private String username;    private String email;    private String phoneNumber;    // Getters and setters, constructors, toString 등}2. Repository 인터페이스 정의JPA Repository 인터페이스를 정의하여 데이터베이스 조작에 필요한 메서드를 선언합니다.Spring Data JPA를 사용하면 구현체는 자동으로 생성됩니다.import org.springframework.data.jpa.repository.JpaRepository;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {    User findByUsername(String username);    // 추가적으로 필요한 메서드 선언 가능}3. application.properties 또는 application.yml 설정데이터베이스 연결 정보를 설정합니다. 데이터베이스 종류, URL, 사용자 이름, 암호 등을 설정합니다.spring.datasource.url=jdbc:mysql://localhost:3306/mydatabasespring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true4. Entity 클래스와 데이터베이스 테이블 매핑Entity 클래스의 각 필드를 데이터베이스 테이블의 컬럼과 매핑하고, 관계를 설정합니다.@Entity@Table(name = \"users\")public class User {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = \"user_id\")    private Long id;    @Column(name = \"username\")    private String username;    @Column(name = \"email\")    private String email;    @Column(name = \"phone_number\")    private String phoneNumber;    // Getters and setters}5. 서비스 계층에서 Repository 사용필요한 비즈니스 로직을 구현하는 서비스 계층에서 Repository 인터페이스를 주입받아 사용합니다.@Servicepublic class UserService {        @Autowired    private UserRepository userRepository;    public User getUserByUsername(String username) {        return userRepository.findByUsername(username);    }    // 추가적인 비즈니스 로직 구현}MyBatisMyBatis는 SQL을 직접 작성하면서 객체와 관계형 데이터베이스를 매핑할 수 있는 프레임워크입니다. MyBatis는 SQL 매핑을 XML이나 어노테이션을 통해 정의하며, 개발자가 직접 SQL을 제어할 수 있는 유연한 방식을 지원합니다.특징      직접 SQL 작성개발자가 직접 SQL을 작성하여 데이터베이스와 상호 작용할 수 있게 해줍니다. 이를 통해 SQL의 세부 사항을 완벽하게 제어할 수 있습니다.        유연성복잡한 쿼리를 쉽게 작성하고 최적화할 수 있습니다.        XML 또는 어노테이션 XML 파일 또는 어노테이션을 사용하여 매핑을 정의할 수 있습니다.  연동 과정1. DB 테이블 생성 및 설정먼저, 데이터베이스에서 필요한 테이블을 생성합니다. 예를 들어, 사용자 정보를 저장할 users 테이블을 생성합니다.CREATE TABLE users (    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(50),    email VARCHAR(50),    phone_number VARCHAR(20));2. 도메인 객체 설계public class User {    private Long id;    private String username;    private String email;    private String phoneNumber;    // Getters and setters, constructors, toString 등}3. Mapper 인터페이스 정의MyBatis에서 사용할 DAO 인터페이스를 정의합니다.public interface UserMapper {    List&lt;User&gt; selectAllUsers();    User selectUserById(Long userId);    void insertUser(User user);    void updateUser(User user);    void deleteUserById(Long userId);}4. XML Mapper 생성DAO 인터페이스의 메서드와 매핑되는 SQL문을 XML 파일로 작성합니다. ex) select, insert, update, delete..&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.mapper.UserMapper\"&gt;    &lt;select id=\"selectAllUsers\" resultType=\"com.example.domain.User\"&gt;        SELECT * FROM users    &lt;/select&gt;    &lt;select id=\"selectUserById\" parameterType=\"Long\" resultType=\"com.example.domain.User\"&gt;        SELECT * FROM users WHERE user_id = #{userId}    &lt;/select&gt;    &lt;insert id=\"insertUser\" parameterType=\"com.example.domain.User\"&gt;        INSERT INTO users (username, email, phone_number)        VALUES (#{username}, #{email}, #{phoneNumber})    &lt;/insert&gt;    &lt;update id=\"updateUser\" parameterType=\"com.example.domain.User\"&gt;        UPDATE users SET            username = #{username},            email = #{email},            phone_number = #{phoneNumber}        WHERE user_id = #{id}    &lt;/update&gt;    &lt;delete id=\"deleteUserById\" parameterType=\"Long\"&gt;        DELETE FROM users WHERE user_id = #{userId}    &lt;/delete&gt;&lt;/mapper&gt;5. MyBatis 설정 파일 작성MyBatis 설정 파일을 작성하여 SQL 맵퍼 파일의 위치와 데이터베이스 연결 정보를 설정합니다.Spring Boot Starter MyBatis 라이브러리를 사용하면 MyBatis 설정 파일(mybatis-config.xml)을 생략할 수 있습니다. Spring Boot가 자동으로 MyBatis와 데이터베이스를 설정해주기 때문입니다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;environments default=\"development\"&gt;        &lt;environment id=\"development\"&gt;            &lt;transactionManager type=\"JDBC\"/&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydatabase\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"password\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"com/example/mapper/UserMapper.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;6. Spring과 MyBatis 연동 설정spring.datasource.url=jdbc:mysql://localhost:3306/mydatabasespring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.cj.jdbc.Drivermybatis.mapper-locations=classpath:/com/example/mapper/*.xml7. 서비스 계층에서 DAO 사용@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public List&lt;User&gt; getAllUsers() {        return userMapper.selectAllUsers();    }    public User getUserById(Long userId) {        return userMapper.selectUserById(userId);    }    public void createUser(User user) {        userMapper.insertUser(user);    }    public void updateUser(User user) {        userMapper.updateUser(user);    }    public void deleteUserById(Long userId) {        userMapper.deleteUserById(userId);    }}"
  },
  
  {
    "title": "웹 애플리케이션 계층",
    "url": "/posts/Layered-Architecture/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-02 14:33:00 +0900",
    





    
    "snippet": "웹 애플리케이션 계층Domain도메인은 소프트웨어 시스템이 다루는 특정 비즈니스 영역을 의미합니다. 도메인은 비즈니스 로직과 규칙을 포함하며, 시스템의 핵심적인 부분을 정의합니다. 주로 엔티티, 값 객체, 도메인 서비스 등이 포함됩니다.주문 시스템을 설계할 때 도메인 계층에서 사용할 수 있는 주요 엔티티 및 서비스 클래스를 예시로 들어보겠습니다.   ...",
    "content": "웹 애플리케이션 계층Domain도메인은 소프트웨어 시스템이 다루는 특정 비즈니스 영역을 의미합니다. 도메인은 비즈니스 로직과 규칙을 포함하며, 시스템의 핵심적인 부분을 정의합니다. 주로 엔티티, 값 객체, 도메인 서비스 등이 포함됩니다.주문 시스템을 설계할 때 도메인 계층에서 사용할 수 있는 주요 엔티티 및 서비스 클래스를 예시로 들어보겠습니다.      값 객체    값 객체는 다음과 같은 특성을 가집니다:          불변성(Immutable): 내부 상태가 변경되지 않습니다.      주로 엔티티의 속성을 나타냅니다.      해당 객체의 의미를 명확하게 정의합니다.        예시로 주소(Address) 클래스와 주문 번호(OrderNumber) record가 있습니다.     public class Address {     private String street;     private String city;     private String zipCode;     // 생성자, getter, equals 등의 메서드 구현 } public record OrderItem(Long productId, int quantity, BigDecimal price) {     // 유효성 검증 로직 등은 생성자에 추가할 수 있음     ... }                Entity : 메인 엔티티는 식별 가능하고 변화하는 객체입니다. 엔티티 내부에는 해당 엔티티의 상태를 관리하고 조작하는 비즈니스 로직이 포함될 수 있습니다.    예시로 주문(Order) 엔티티 클래스가 있습니다.     @Entity @NoArgsConstructor @AllArgsConstructor @Table(name = \"order\") public class Order {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;     private String orderNumber;      @OneToMany(mappedBy = \"order\")     private List&lt;OrderItem&gt; orderItems;//OrderItem 값 객체     private Address shippingAddress; //Address 값 객체     ...     public BigDecimal calculateTotalAmount() {...}     public void changeStatus(OrderStatus newStatus) {...}     ... }        이외에도 OrderItem, Customer, Product, Payment, Shipment 등의 엔티티가 존재할 수 있습니다.         Domain Service: 도메인 서비스는 여러 엔티티 간의 복잡한 비즈니스 로직을 처리합니다. 도메인 서비스는 주로 한 엔티티의 책임으로 정의하기 어렵거나, 여러 엔티티를 조작해야 하는 비즈니스 로직을 캡슐화합니다.     @Service @RequiredArgsConstructor public class OrderService {     private final OrderRepository orderRepository;     private final ProductService productService;     private final PaymentService paymentService;     @Transactional     public Order createOrder(OrderData orderData) {...}     @Transactional     public void cancelOrder(Long orderId) {...}     public Order getOrderDetails(Long orderId) {...}     public List&lt;Order&gt; listOrdersByCustomer(Long customerId) {...} }        주문 상태 변경, 결제 처리, 재고 감소 등 비즈니스 로직이 있습니다.      도메인 엔티티 vs 도메인 서비스      도메인 엔티티:개별 엔티티의 상태를 관리하고 조작하는 비즈니스 로직을 포함합니다.주로 엔티티의 속성 값을 검증하고, 상태 전이를 관리합니다.예: Order 엔티티의 calculateTotalAmount 메서드나 changeStatus 메서드        도메인 서비스:여러 엔티티와 상호작용하여 수행해야 하는 비즈니스 로직을 처리합니다.단일 엔티티의 책임으로 정의하기 어려운 로직을 포함합니다. 예: OrderService의 createOrder 메서드, cancelOrder 메서드  Application Service애플리케이션 서비스는 사용자 인터페이스(UI)와 도메인 사이의 중개자 역할을 수행합니다. 클라이언트의 요청을 받아 처리하고, 도메인 서비스를 호출하여 비즈니스 로직을 실행하며, 트랜잭션 관리 및 예외 처리 등의 업무를 담당합니다.주문 애플리케이션 서비스 예시@Service@RequiredArgsConstructorpublic class OrderApplicationService {    private final OrderService orderService;    private final CustomerService customerService;    private final ProductService productService;    private final PaymentService paymentService;    public OrderDTO placeOrder(OrderData orderData) {...}    public void cancelOrder(Long orderId) {...}    public OrderDTO getOrder(Long orderId) {...}    public List&lt;OrderDTO&gt; listCustomerOrders(Long customerId) {...}    private OrderDTO convertToDTO(Order order) {...}}RepositoryRepository는 데이터베이스의 데이터를 관리하고 접근하는 객체입니다. 주로 CRUD(Create, Read, Update, Delete) 연산을 수행하여 데이터의 영속성을 관리하며, 데이터베이스의 특정 테이블이나 엔티티에 대한 접근을 추상화합니다.예를 들어, Spring Framework에서는 JpaRepository 인터페이스를 통해 간편하게 Repository를 정의할 수 있습니다:public interface UserRepository extends JpaRepository&lt;Item, Long&gt;{    User findById(String id);    User findByUsername(String username);    User save(User user);    void delete(User user);    List&lt;User&gt; findAll();    ...}Repository와 DAO의 차이점DAO (Data Access Object)DAO는 데이터베이스와의 직접적인 상호작용을 담당하는 객체입니다. 주로 순수한 SQL 쿼리나 JDBC 코드를 이용하여 데이터베이스와의 연동을 처리합니다. DAO는 데이터베이스의 특정 테이블이나 객체에 집중하여 CRUD(Create, Read, Update, Delete) 연산을 수행하며, 데이터베이스 연결과 트랜잭션 관리를 프로그래머가 직접 처리해야 합니다.RepositoryRepository는 데이터 액세스 코드를 추상화하여 개발자가 보다 간편하게 데이터베이스와 상호작용할 수 있도록 도와주는 객체입니다. 주로 ORM 프레임워크를 사용하여 데이터베이스와의 상호작용을 추상화하며, 프레임워크가 제공하는 기능을 통해 CRUD 연산을 자동으로 처리할 수 있습니다. Repository는 개발자가 데이터베이스 연결과 트랜잭션 관리를 프레임워크에 위임하여 코드의 간결성을 유지할 수 있습니다."
  },
  
  {
    "title": "데이터 접근과 전송을 위한 객체들 - DAO, DTO, VO, Record, Entity",
    "url": "/posts/data-objects/",
    "categories": "Development, Spring",
    "tags": "spring, java",
    "date": "2024-07-01 14:33:00 +0900",
    





    
    "snippet": "DAO (Data Access Object)  데데이터 액세스 로직을 담당하는 객체주로 JDBC나 Hibernate 같은 ORM 프레임워크를 사용하지 않고 순수한 SQL 쿼리나 JDBC 코드를 이용하여 데이터베이스와 상호작용을 합니다.import java.sql.Connection;import java.sql.PreparedStatement;impor...",
    "content": "DAO (Data Access Object)  데데이터 액세스 로직을 담당하는 객체주로 JDBC나 Hibernate 같은 ORM 프레임워크를 사용하지 않고 순수한 SQL 쿼리나 JDBC 코드를 이용하여 데이터베이스와 상호작용을 합니다.import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class UserDao {        private Connection connection;    public UserDao(Connection connection) {        this.connection = connection;    }    public void save(User user) throws SQLException {...}    public User findById(Long id) throws SQLException {...}    // 기타 데이터 액세스 메서드들...}위의 예제에서 Connection 객체를 사용하여 데이터베이스와의 연결을 설정하고, save 메서드와 findById 메서드를 통해 데이터베이스와 상호작용합니다.DTO (Data Transfer Object)  계층 간 데이터 전송을 위한 객체로, 비즈니스 로직을 포함하지 않습니다.주로 서로 다른 계층(예: 클라이언트와 서버) 간 데이터 교환에 사용됩니다.필요한 데이터만을 담아서 전송함으로써 효율적인 데이터 교환을 지원하고, 클라이언트와의 인터페이스를 명확히 정의합니다.@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class UserDTO {    private Long id;    private String username;    private String email;    @Override    public String toString() {...}}VO (Value Object)  변경 불가능하며 읽기 전용으로 사용되는 객체로, 데이터의 일관성을 보장합니다.보통 도메인 모델에서 중요한 값을 나타냅니다.불변성을 가지며, 값을 캡슐화하여 의미 있는 단위로 표현합니다.@Getterpublic class User {    private final Long id; //주민등록번호    private final String name;    public User(Long id, String name) {...}    @Override    public boolean equals(Object obj) {...}    @Override    public int hashCode() {...}    @Override    public String toString() {...}}Record  Java에서 데이터를 저장하고 접근하기 위한 불변 클래스로, 간단한 데이터 구조를 표현합니다.자동으로 생성되는 Getter, equals, hashCode, toString 등의 메서드를 제공하여 코드를 간소화합니다.주로 데이터를 효율적으로 저장하고 접근하기 위해 사용됩니다.public record UserRecord(String username, String email) {}Entity  데이터베이스의 테이블과 매핑되는 객체데이터베이스의 구조를 반영하며, JPA와 같은 ORM(Object-Relational Mapping) 프레임워크를 통해 데이터베이스와 상호작용합니다.@Entity@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Table(name = \"users\")public class User {        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String username;    private String email;        @Override    public String toString() {...}}DTO를 사용하는 이유굳이 DTO를 사용하는 이유는 뭘까? 그냥 필요할 때마다 요청해서 값을 받아오면 되는거 아닌가?      데이터 전송의 효율성 : DTO는 필요한 데이터만을 담아 전송함으로써 네트워크 트래픽을 줄이고 성능을 최적화할 수 있습니다. 클라이언트와 서버 간의 데이터 교환을 최소화하여 응답 시간을 단축시키는 데 기여합니다.        명확한 데이터 정의 : DTO는 클라이언트에게 제공되는 데이터의 형태를 명확히 정의함으로써 개발자 간의 협업과 이해를 쉽게 만듭니다. 데이터 필드와 그 의미를 명확히 정의하여 혼란을 줄이고, 의도하지 않은 데이터 전달 오류를 방지할 수 있습니다.        데이터 노출 제어 : DTO는 클라이언트에게 전달되는 데이터를 특정 형태로 제한함으로써 데이터 노출을 관리할 수 있습니다. 클라이언트에게 필요하지 않은 정보를 노출하지 않고, 보안적인 측면에서도 더 안전한 방식으로 데이터를 처리할 수 있습니다.  DTO, VO, Recrod 비교DTO, VO, Record는 데이터를 저장하고 접근하기 위한 목적으로 설계된 역할로, 유사한 점이 있지만 각각의 객체는 다음과 같은 목적과 사용 방법에서 차이가 있습니다.      DTO: 데이터 전송을 단순화하고, 서로 다른 계층 간의 데이터 교환을 표현하기 위해 사용됩니다. 주로 필드들이 mutable하게 관리됩니다. 예를 들어, 클라이언트가 입력한 데이터를 서버로 전송하거나, 서버에서 클라이언트로 데이터를 반환할 때 사용됩니다.        VO: 도메인의 일관성과 값을 보장하기 위해 사용됩니다. 불변성을 가지므로 한 번 설정된 값은 변경되지 않습니다. 도메인 객체의 특정 값(예: 금액, 주소, 식별자 등)을 표현하며, 값의 일관성을 보장하는 데 중점을 둡니다.        Record: 데이터를 간단하게 저장하고 접근하는 데 사용되며, 자동 생성되는 메서드를 통해 코드를 간소화할 수 있습니다.  결론각각의 객체는 자신의 목적과 사용하는 컨텍스트에 맞게 설계되어 있습니다. DTO는 데이터 전송의 효율성을 높이고, VO는 값의 일관성을 유지하며, Record는 데이터를 간단하게 관리하는 데 중점을 둡니다. 이들을 목적에 맞게 구분하여 사용하면 코드의 가독성과 유지보수성을 높일 수 있습니다."
  },
  
  {
    "title": "Spring MVC의 구조",
    "url": "/posts/Spring-MVC/",
    "categories": "Development, Spring",
    "tags": "spring, mvc",
    "date": "2024-06-30 14:33:00 +0900",
    





    
    "snippet": "MVC 패턴이란?MVC (모델-뷰-컨트롤러) 패턴은 소프트웨어 디자인 패턴으로, 애플리케이션을 세 가지 주요 부분으로 나누어 개발합니다. 이 패턴은 사용자 인터페이스, 데이터, 그리고 비즈니스 로직을 더 쉽게 관리하고 유지보수하기 위해 널리 사용됩니다.  Model(모델)          모델은 데이터와 게임 로직을 담당              비즈니...",
    "content": "MVC 패턴이란?MVC (모델-뷰-컨트롤러) 패턴은 소프트웨어 디자인 패턴으로, 애플리케이션을 세 가지 주요 부분으로 나누어 개발합니다. 이 패턴은 사용자 인터페이스, 데이터, 그리고 비즈니스 로직을 더 쉽게 관리하고 유지보수하기 위해 널리 사용됩니다.  Model(모델)          모델은 데이터와 게임 로직을 담당              비즈니스 로직과 데이터 상태를 관리      데이터의 상태 변화와 업데이트를 처리      데이터를 가져오거나 업데이트하는 데 필요한 메서드와 속성을 제공        View(뷰)          뷰는 사용자 인터페이스와 출력을 담당              사용자 인터페이스(UI)를 나타내며, 데이터를 표시하고 사용자 입력을 받음      모델의 변경 사항을 감지하여 업데이트      데이터와 사용자 인터페이스를 분리        Controller(컨트롤러)          컨트롤러는 사용자 입력을 처리하고 모델과 뷰를 조정              사용자 입력을 처리하고, 모델 및 뷰 간의 상호작용을 조정      모델과 뷰 사이의 중개 역할을 수행      사용자 입력에 따라 모델을 업데이트하고 뷰를 업데이트하는 메서드를 제공      Spring MVC란?Spring MVC는 Spring 프레임워크에서 제공하는 웹 모듈입니다. 이 모듈은 Model, View, Controller 세 가지 주요 구성 요소를 사용하여 사용자의 요청을 받아들이고, 데이터를 처리하며, 최종적으로 사용자에게 화면을 제공하는 과정을 효율적으로 관리할 수 있습니다.Spring MVC의 구조DispatcherServlet : HTTP Request를 처리하는 ControllerDispatcherServlet은 Spring MVC의 핵심이 되는 서블릿입니다. 클라이언트로부터 HTTP 요청이 들어왔을 때, DispatcherServlet은 모든 HTTP 요청을 수신하고, 요청을 처리할 컨트롤러를 찾아 요청을 전달하며, 응답을 생성하여 클라이언트에게 반환하는 역할을 합니다.HandlerMapping : HTTP Request URL을 어떤 컨트롤러가 처리할지 결정HandlerMapping은 HTTP 요청 URL을 분석하여 어떤 컨트롤러가 해당 요청을 처리할지 결정합니다. 이를 통해 요청 URL과 컨트롤러 메서드를 매핑합니다.HandlerAdapter : 컨트롤러를 실행하고 결과를 생성HandlerAdapter는 HandlerMapping에 의해 결정된 컨트롤러를 실행하는 역할을 합니다. HandlerAdapter는 해당 컨트롤러의 메서드를 호출하고, 그 결과를 처리하여 DispatcherServlet에 Model 객체와 View 이름을 반환합니다.Handler : HTTP Request 처리하고, 비지니스 로직을 실행하여 결과를 생성하는 Controller컨트롤러는 HTTP 요청을 처리하고 비즈니스 로직을 실행하여 결과를 생성하는 역할을 합니다. HandlerAdapter를 통해 해당 컨트롤러의 메서드가 호출되며, 비즈니스 로직을 처리한 결과를 반환합니다.  비즈니스 로직의 흐름          Service : 비즈니스 로직을 처리하는 레이어. 비즈니스 규칙과 트랜잭션 관리를 담당합니다.      DAO : 데이터베이스와 상호작용하는 레이어. 데이터를 생성, 읽기, 업데이트, 삭제(CRUD) 작업을 수행합니다.      DB : 실제 데이터를 저장하고 관리하는 데이터베이스 시스템. DAO를 통해 접근됩니다.      ViewResolver : 논리적 뷰 이름을 실제 View 객체로 변환ViewResolver는 컨트롤러가 반환한 논리적인 뷰 이름을 실제 View 객체로 변환합니다. 이를 통해 논리적 뷰 이름을 기반으로 적절한 뷰를 찾아 렌더링할 수 있도록 합니다.View : 사용자에게 보여지는 화면을 렌더링최종적으로 클라이언트에게 표시되는 페이지를 만듭니다."
  },
  
  {
    "title": "LF will be replaced by CRLF 경고",
    "url": "/posts/CRLF-Error/",
    "categories": "Blogging",
    "tags": "blog",
    "date": "2024-06-27 16:33:00 +0900",
    





    
    "snippet": "Git에 파일을 커밋하려고 git add -A를 실행할 때, 아래와 같은 경고 메시지가 나타날 수 있습니다.LF will be replaced by CRLF the next time Git touches it이 메시지는 Git이 파일의 줄바꿈 문자를 바꾸려고 한다는 경고입니다. 쉽게 말해서, 파일의 줄바꿈 방식이 변경될 것이라는 뜻입니다.그렇다면 왜 ...",
    "content": "Git에 파일을 커밋하려고 git add -A를 실행할 때, 아래와 같은 경고 메시지가 나타날 수 있습니다.LF will be replaced by CRLF the next time Git touches it이 메시지는 Git이 파일의 줄바꿈 문자를 바꾸려고 한다는 경고입니다. 쉽게 말해서, 파일의 줄바꿈 방식이 변경될 것이라는 뜻입니다.그렇다면 왜 줄바꿈 방식이 변경되는 것일까? Git은 기본적으로 플랫폼 간 호환성을 위해 줄바꿈 문자를 자동으로 변환하려고 합니다. 예를 들어, Windows에서 작업한 파일을 커밋하면 Git은 파일의 줄바꿈 문자를 LF에서 CRLF로 변환하여 저장할 수 있습니다. 이 변환 과정이 경고 메시지를 발생시키는 이유입니다.해결 방법은 Git이 CRLF 대신 LF를 사용하도록 설정을 변경하는 것입니다. 다음 명령어를 실행한 후 다시 git add를 시도하면 문제 없이 파일을 추가할 수 있습니다.git config --global core.autocrlf true이 명령어는 Git의 core.autocrlf 설정을 전역적으로 true로 변경하여, Git이 자동으로 CRLF를 LF로 변환하도록 합니다."
  },
  
  {
    "title": "jekyll로 GitHub Pages 만들기(3)",
    "url": "/posts/chirpy-custom/",
    "categories": "Blogging",
    "tags": "blog",
    "date": "2024-06-27 14:33:00 +0900",
    





    
    "snippet": "개발자 도구저는 보통 CSS를 수정할 때 크롬 개발자 도구(F12)를 활용하여 미리 구성을 확인한 다음, VSCode에서 수정하는 방식으로 진행하고 있습니다.커스터마이징  프로필 사진 변경  사이드바 수정  Favicon 이미지 변경프로필 사진프로필 이미지는 /assets/img/ 폴더에 넣으면 됩니다. 로컬에서는 해당 경로만 적어도 잘 나오지만 원격...",
    "content": "개발자 도구저는 보통 CSS를 수정할 때 크롬 개발자 도구(F12)를 활용하여 미리 구성을 확인한 다음, VSCode에서 수정하는 방식으로 진행하고 있습니다.커스터마이징  프로필 사진 변경  사이드바 수정  Favicon 이미지 변경프로필 사진프로필 이미지는 /assets/img/ 폴더에 넣으면 됩니다. 로컬에서는 해당 경로만 적어도 잘 나오지만 원격에 올리면 이미지가 제대로 뜨지 않는 오류가 발생할 수 있습니다. 이 문제를 해결하기 위해 절대 경로를 사용해야 합니다.https://pingppung.github.io/assets/img/사진이름.확장자사이드바개발자 모드로 찾아본 기존 Chirpy의 사이드바 CSS는 아래와 같습니다.#sidebar {    padding-left: 0;    padding-right: 0;    position: fixed;    top: 0;    left: 0;    height: 100%;    overflow-y: auto;    width: 260px;    z-index: 99;    background: #c7d6e6;    border-right: 1px solid var(--sidebar-border-color);    text-align: center;    -ms-overflow-style: none;    scrollbar-width: none;}사이드바 배경 설정사이드바의 CSS를 변경하려면 _sass/addon 폴더 내의 custom.scss 파일을 수정합니다. 예를 들어, 사이드바의 색상을 변경하려면 background 속성을 변경하면 됩니다.사이드바에 배경 이미지를 추가하려면 custom.scss 파일에 다음 코드를 추가합니다..sidebar {  background-image: url('https://pingppung.github.io/assets/img/background.jpg');  background-size: cover;}Contact 정보 변경_data 폴더 내의 contact.yml 파일을 수정하여 연락처 정보를 업데이트합니다.필요하신 부분 이외에는 삭제하거나 주석처리하면 사라집니다.아이콘부분은 fontawesome에서 원하는 아이콘으로 변경할 수 있습니다.favicon 이미지Favicon은 브라우저 탭에 표시되는 이미지를 말합니다. Favicon은 이미지나 글자 등 본인이 원하는대로 제작을 하신 후 favicon 제작 사이트에서 ico를 생성합니다. 생성한 파일들을 /assets/img/favicon/ 폴더에 덮어씌웁니다.만약, 파일명이 다르면 favicon을 적용시키는 파일을 찾아 경로를 수정해야 합니다. 저는 파일명이 같기 때문에 경로를 수정하는 과정은 진행하지 않았습니다.  저는 작가 rawpixel.com 무료 이모지를 사용했습니다.  출처 Freepik"
  },
  
  {
    "title": "jekyll로 GitHub Pages 만들기(2)",
    "url": "/posts/chirpy-setting/",
    "categories": "Blogging",
    "tags": "blog",
    "date": "2024-06-26 14:33:00 +0900",
    





    
    "snippet": "chirpy 환경 설정본인 블로그 환경에 맞춰 _config.yml 파일 설정을 변경해야합니다.제가 수정한 부분만 적어두었습니다.theme: jekyll-theme-chirpylang: kotimezone: Asia/Seoultitle: 블로그 제목tagline: title의 부연 설명description: SEO를 위한 키워드url: 블로그 실제 u...",
    "content": "chirpy 환경 설정본인 블로그 환경에 맞춰 _config.yml 파일 설정을 변경해야합니다.제가 수정한 부분만 적어두었습니다.theme: jekyll-theme-chirpylang: kotimezone: Asia/Seoultitle: 블로그 제목tagline: title의 부연 설명description: SEO를 위한 키워드url: 블로그 실제 url \"ex)https://pingppung.github.io\"github:    username: 본인의 github 닉네임 입력social:    name: 본인 닉네임 or 이름    email: 본인 이메일 계정    links: 소셜 링크들avatar: 왼쪽 바에 표시될 이미지의 경로배포변경된 내용을 커밋하고 원격 저장소로 푸시합니다.git add -Agit commit -m \"커밋 메시지\"git push문제 해결1. — layout: home # Index page —로컬 환경에서는 사이트가 잘 실행되었지만, push 후 웹페이지에 접속하면 다음과 같은 화면이 나타나는 문제가 발생했습니다.해결방안  GitHub Actions 설정 변경      해당 GitHub Repository의 Settings로 이동        Pages 섹션에서 Build and Deployment의 Source를 GitHub Actions로 변경        Configure를 클릭하여 jekyll.yml을 커밋    기존 배포 설정 파일 삭제      원래 github/workflows 폴더 내에 있던 pages-deploy.yml 파일을 삭제        삭제 후 커밋 &amp; push  2. js파일 does not exist원격 저장소로 push하면 internal scripy /assets/js/dist/*.min.js does not exist. 오류 발생해결방안해당 명령어로 /assets/js/dist/*.min.js 파일 생성npm install &amp;&amp; npm run build..gitignore 파일에 다음 부분을 주석 처리# Misc# _sass/dist# assets/js/dist3. jekyll-theme-chirpy.scss 위치다른 분들의 블로그를 참고하여 jekyll-theme-chirpy.scss 파일을 _sass 폴더 내에 위치시켰을 때 /app.min.js 오류가 발생했었습니다.그러나 원래 상태인 /assets/css/ 폴더 밑에 위치시켜도 실행 잘 되니깐 옮기지 마세요!! 저도 파일 구조가 왜 다르지 하고 옮겼다가 오류나서 시간 엄청 잡아먹었습니다.😱마무리GitHub 블로그 생성을 완료했습니다. 다음 단계로는 Chirpy 테마를 커스터마이징하는 과정에 대해 설명하겠습니다."
  },
  
  {
    "title": "jekyll로 GitHub Pages 만들기(1)",
    "url": "/posts/jekyll-start/",
    "categories": "Blogging",
    "tags": "blog",
    "date": "2024-06-26 12:33:00 +0900",
    





    
    "snippet": "개발 블로그 시작하기글을 못 쓰기도 했고 누군가 내 글을 볼 수 있다는 생각에 블로그를 꺼려졌습니다. 이로 인해 지금까지는 필요한 내용만 노션에 작성하는 식으로 진행해왔습니다. 그러나 면접 준비를 하면서 기술 지식이 부족하다는 것을 깨닫고, 이를 극복하기 위해 블로그를 시작하여 기술적인 내용을 깊이 있게 공부하고자 합니다.개발 블로그를 시작하기 위해서...",
    "content": "개발 블로그 시작하기글을 못 쓰기도 했고 누군가 내 글을 볼 수 있다는 생각에 블로그를 꺼려졌습니다. 이로 인해 지금까지는 필요한 내용만 노션에 작성하는 식으로 진행해왔습니다. 그러나 면접 준비를 하면서 기술 지식이 부족하다는 것을 깨닫고, 이를 극복하기 위해 블로그를 시작하여 기술적인 내용을 깊이 있게 공부하고자 합니다.개발 블로그를 시작하기 위해서 많은 고민을 해왔습니다. 어떤 플랫폼을 사용하면 좋을까?Velog, GitHub Pages, 네이버 블로그, 티스토리 등 여러 가지 블로그 플랫폼 중에서 어떤 것을 선택해야 할지 많은 고민했습니다.최종적으로 깔끔한 디자인으로 커스터마이징할 수 있다는 점과 마크다운 지원을 우선순위로 두고 GitHub Pages를 사용하기로 결정했습니다.로컬 환경 설정1. Ruby 설치jekyll 사용하기 위해서는 Ruby를 설치해줘야 합니다. → 꼭 Devkit 있는 버전으로 다운받기!! https://rubyinstaller.org/downloads/2. 깃허브 Repository 생성본인 깃허브 계정명.github.io의 Repository를 생성해줘야합니다.Repository이 생성됐다면, 본인 컴퓨터에 로컬 저장소에 clone을 해주면 됩니다git clone https://github.com/{github_username}/{github_username}.github.io  3. jekyll 설치gem install jekyllgem install bundlerchirpy 테마 설치Chirpy 테마를 설치하는 방법에 대해서는 소스를 zip 파일로 다운로드 받아 설치하는 작업으로 진행했습니다.1. Chirpy GitHub에서 zip 파일 다운로드먼저, Chirpy 테마의 GitHub 저장소에서 최신 소스 코드를 zip 파일로 다운로드합니다.2. 다운받은 파일 본인 로컬 저장소로 옮기기다운로드한 zip 파일을 본인의 로컬 저장소에 적절한 위치로 옮깁니다.3. chirpy 초기화Linux에서는 `bash tools/init.sh 명령어로 chirpy 테마를 초기화할 수 있습니다. 하지만 Windows에서는 이 명령어를 사용할 수 없으므로, 수동으로 초기화를 진행해야 합니다. 아래는 Windows에서 chirpy 테마 초기화를 위한 과정입니다:  github/workflows/pages-deploy.yml 파일을 제외한 나머지 파일 삭제→ starter 폴더 내에 있는 경우엔 옮기고 해당 폴더 삭제해도 상관 X  docs 폴더 삭제  Gemfile.lock 파일 삭제이외에도 추가적으로 다른 블로그에서는 삭제해야될 파일, 폴더가 있는 경우, 본인의 판단에 맞게 진행하면 됩니다. 저는 해당 파일과 폴더만 삭제 후 다음 과정을 진행했습니다.4. 로컬에서 실행아래 명령어를 입력 후 http://127.0.0.1:4000/ 로 접속하면 완료cd 로컬 저장소 주소  bundle  //Gemfile.lock 파일 생성하는 과정bundle exec jekyll serve마무리로컬 환경에서의 블로그 구성이 완료되었습니다. 다음 포스트에서는 원하는 블로그 환경으로 수정하고 GitHub에 업로드하는 과정을 마무리짓겠습니다."
  },
  
  {
    "title": "chirpy의 기본 post",
    "url": "/posts/text-and-typography/",
    "categories": "Blogging, Demo",
    "tags": "typography",
    "date": "2019-08-08 12:33:00 +0900",
    





    
    "snippet": "HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risu...",
    "content": "HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risus, sit amet vulputate urna facilisis ac. Phasellus semper dui non purus ultrices sodales. Aliquam ante lorem, ornare a feugiat ac, finibus nec mauris. Vivamus ut tristique nisi. Sed vel leo vulputate, efficitur risus non, posuere mi. Nullam tincidunt bibendum rutrum. Proin commodo ornare sapien. Vivamus interdum diam sed sapien blandit, sit amet aliquam risus mattis. Nullam arcu turpis, mollis quis laoreet at, placerat id nibh. Suspendisse venenatis eros eros.ListsOrdered list  Firstly  Secondly  ThirdlyUnordered list  Chapter          Section                  Paragraph                    ToDo list  Job          Step 1      Step 2      Step 3      Description list  Sun  the star around which the earth orbits  Moon  the natural satellite of the earth, visible by reflected light from the sunBlock Quote  This line shows the block quote.Prompts  An example showing the tip type prompt.  An example showing the info type prompt.  An example showing the warning type prompt.  An example showing the danger type prompt.Tables            Company      Contact      Country                  Alfreds Futterkiste      Maria Anders      Germany              Island Trading      Helen Bennett      UK              Magazzini Alimentari Riuniti      Giovanni Rovelli      Italy      Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.Code blocksCommonThis is a common code snippet, without syntax highlight and line number.Specific Languageif [ $? -ne 0 ]; then  echo \"The command was not successful.\";  #do the needful / exitfi;Specific filename@import  \"colors/light-typography\",  \"colors/dark-typography\";MathematicsThe mathematics powered by MathJax:\\[\\begin{equation}  \\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}  \\label{eq:series}\\end{equation}\\]We can reference the equation as \\eqref{eq:series}.When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Mermaid SVG gantt  title  Adding GANTT diagram functionality to mermaid  apple :a, 2017-07-20, 1w  banana :crit, b, 2017-07-23, 1d  cherry :active, c, after b a, 1dImagesDefault (with caption)Full screen width and center alignmentLeft alignedFloat to leftPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Float to rightPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Dark/Light mode &amp; ShadowThe image below will toggle dark/light mode based on theme preference, notice it has shadows.VideoReverse Footnote            The footnote source &#8617;&#xfe0e;              The 2nd footnote source &#8617;&#xfe0e;      "
  }
  
]

